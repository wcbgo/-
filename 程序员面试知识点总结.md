# 程序员面试知识点总结

## python

### 元组和列表的区别

#### 相同点

##### 都是序列

##### 都可以存储任何数据类型

##### 可以通过索引访问

#### 不同点

##### 语法差异

###### 使用方括号\[\]创建列表，使用（）创建元组

##### 是否可变

###### 列表是可变的，元组不可变

####### 不能将列表作为字典的key，元组可以

##### 重用与拷贝

###### 元组无法复制，因为元组是不可变的

##### 大小差异

###### python将低开销的较大的块分配给元组，因为它们是不可变的。对于列表分配小内存块。与列表相比，元组的内存更小。当拥有大量元素时，元组比列表快。

####### 列表可以看成是动态数组,它们是可变的并且可以重新设定长度

####### 元组可以看成是静态的数组,它们是不可变的,并且长度也是一旦创建就无法改变

##### 同构与异构

###### 元组多用于存储异构元素，即不同数据类型的元素。列表用于存储同构元素。

####### 设计初衷

######## 列表

######### 用来保存多个相互独立对象的数据集合

######## 元组

######### 元组设计的初衷就是为了描述一个不会改变的事物的多个属性

### 多线程怎么实现

#### 通过threading模块创建新的线程有两种方法

##### threading.Thread

##### 继承threading.Thread定义子类并重写run()方法

#### Python有一个GIL（Global Interpreter Lock）机制，任何线程在运行之前必须获取这个全局锁才能执行，每当执行完100条字节码，全局锁才会释放，切换到其他线程执行。

#### 线程同步

##### 锁机制

###### threading的Lock类，用该类的acquire函数进行加锁，用realease函数进行解锁

##### 信号量

##### 队列

###### queue

####### queue.put(item) 写入队列

####### queue.get(\[block\[, timeout\]\])获取队列

##### 条件判断

#### 线程池

##### 一个线程的运行时间可以分为3部分：线程的启动时间、线程体的运行时间和线程的销毁时间。

##### 能够避免多次创建线程

#### 协程

##### 对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保持状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。

##### 协程的适用场景： 当程序中存在大量不需要CPU的操作时（IO），适用于协程。

##### 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法，进入上一次离开时所处逻辑流的位置。

##### 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是有程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

##### 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

##### 因为协程是一个线程执行，那么怎么利用多核CPU呢？最简单的方法是多进程加协程，既充分利用多核，有充分发挥协程的高效率，可获得极高的性能。

##### yield

##### greenlet

##### gevent

###### 猴子补丁

####### 属性在运行时的动态替换

####### 允许在运行期间修改一个类或模块

##### 什么是协程

###### 协程是比线程更小的一种执行单元

###### 由于线程是操作系统的最小执行单元，因此也可以得出，协成是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的。

####### 使用协程是因为线程的切换成本比较高，而协程在这方面很有优势。

###### 而线程的调度是在操作系统中进行的，而协程调度则是在用户空间进行的，是开发人员通过调用系统底层的执行上下文相关api来完成的，

### Python的内存管理机制

#### python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。为python的堆空间分配内存的是python的内存管理模块进行的，核心api会提供一些访问该模块的方法供程序员使用。python自有的垃圾回收机制回收并释放没有被使用的内存供别的程序使用。

#### 对象的内存使用

##### 在python中整数和短小的字符，python都会缓存这些对象，以便重复使用，当我们创建多个等于1的引用的时候，实际是让所有引用都指向同一个对象

##### 在python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)

###### 我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，会创建一个临时引用，所以结果会比预期多1。

#### 对象引用对象

##### python的一个容器对象（container），比如列表字典等，可以包含多个对象。实际上，容器对象中包含的并不是对象本身，而是指向各个元素对象的引用。

##### 两个对象可能互相引用，从而构成所谓的引用环（reference cycle）

#### 引用减少

##### 如果某个引用指向对象a，当这个引用被重新定向到其他对象b的时候，对象a的引用计数会减少

#### 垃圾回收

##### 从基本原理来说，当一个对象的引用计数降为0的时候，说明没有任何引用指向对象，这时候该对象就成为需要被清除的垃圾了。比如某个新建对象，分配给某个引用，引用数为1,当引用被删除之后，引用数为0，那么该对象就可以被垃圾回收。

##### 然而清理过程是个费力的过程。垃圾回收的时候，python不能进行其他的任务，频繁的垃圾回收，会大大降低python的工作效率。如果内存中的对象不多，就没必要总启动垃圾回收。所以python只会在特定的条件下，自动启动垃圾回收。当python运行的时候，会记录其中分配对象和取消分配对象的次数，两者的差值高于某个阈值的时候，垃圾回收才会启动。 我们可以通过gc模块的get\_threshold()来查看该阈值。

###### 也可以手动使用gc.collect()启动垃圾回收机制。

###### gc.get\_threshold()

####### (700, 10, 10)

#### 分代回收

##### 这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。

##### python将所有的对象分为0,1,2三代，所有新建的对象都是0代对象，当某一代对象经历过垃圾回收之后，依然存活，那就归入到下一代中，垃圾回收启动时，一定会扫描所有的0代对象。如果0代对象经历过一定次数的垃圾回收，那么就启动对0待和1代的扫描清理，当1代也经历了一定数量的垃圾回收，那就启动对0,1,2，即所有的对象进行扫描。

###### 上面gc.get\_threshold()返回的（700,10,10）中后面的两个数，意义就是，每经过10次对0代的垃圾回收，就会配合启动一次对1代的扫描，没经过10次对1代的扫描，才会启动一次对2代的垃圾回收。

#### 引用环

##### 引用环的存在会给垃圾回收带来很大的困难，这些引用环可能构成无法使用，但是引用计数不为0的一些对象。

##### 为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc\_ref。假设，每个对象i，该计数为gc\_ref\_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc\_ref\_j减1。

###### 在结束遍历后，gc\_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。

### 堆栈的区别

#### 堆里面存放的是具体的对象，在堆中Python会为其分配具体的内存空间，此地址即为此对象在内存中的地址

#### 栈里面存放的是对象的地址，（引用的地址）而不是对象本体

#### 在Python中会为匿名列表对象（即不存在变量名的引用）和匿名字典对象以及短字符串创建缓存区，，并且Python自带小对象整数池（-5\~256）

#### 

##### 针对匿名列表和字典对象(即不存在变量名的引用)

###### 列表和字典这种可变对象当为匿名对象是会向外暴露一个内存地址,不论里面的内容怎么变，该地址不变

##### 针对短字符串

###### Python会为短字符串创建内存缓存，即针对相同的短字符串，只会创建一个内存空间，不会为相同的短字符串创建多个内存空间，但是长字符串不会如此

##### 针对小整数

###### Python会为（-5，256）之间的整数分配独立的内存空间，当有对象调用的时候会直接从里面取地址，不论调用多少次，都不会再为这些对象创建新的内存空间

#### 往这两个哪里存数据比较快

##### 就普通的操作而言分配栈空间仅仅是一个指针操作,

##### 访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。

##### 栈有专门的寄存器，压栈和出栈的指令效率很高，而堆需要由OS动态调度，堆内存可能被OS调度在非物理内存中，或是申请内存不连续，造成碎片过多等问题。 另外，分配方式上，堆都是动态分配的，栈是编译器完成的。栈的分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现

##### 首先, 栈是本着LIFO原则的存储机制, 对栈数据的定位相对比较快速, 而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位. 

##### 其次, 栈是由CPU提供指令支持的, 在指令的处理速度上, 对栈数据进行处理的速度自然要优于由操作系统支持的堆数据. 

##### 再者, 栈是在一级缓存中做缓存的, 而堆则是在二级缓存中, 两者在硬件性能上差异巨大. 

### Python出现乱码的原因

#### Python在读取时默认解码方式是用操作系统编码,如果和保存时的编码方式不一样，就会出现乱码。

#### 因为windows默认的编码方式是GBK，python文件保存时使用了utf-8,在读取时,python使用GBK的编码表去解utf-8编码的字节码，因为GBK与UTF-8编码不兼容，自然出现了乱码问题

### Python的GIL是什么

#### 全局解释器锁（global interpreter lock）

##### 每个线程在执行时候都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，即同一时刻只有一个线程使用CPU，也就是说多线程并不是真正意义上的同时执行

##### 如何解决

###### 使用多进程完成多线程的任务

####### python下想要充分利用多核CPU，就用多进程

######## 每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)

###### 在使用多线程可以使用c语言去实现

###### 更换cpython为jpython

##### cpython在解析多线程时, 会上GIL锁, 保证同时只有一个线程占用锁

##### 什么时候会释放GIL锁

###### python2

####### 在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。

######## 而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。

###### python3

####### 在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好

###### io等耗时操作

##### 每个线程的执行方式

###### 1.获取GIL

###### 2.执行代码直到sleep或者是python虚拟机将其挂起。

###### 3.释放GIL

##### 多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低

#### CPU密集程序难以利用多核优势 IO期间会释放GIL，对IO密集程序影响不大（爬虫，web）

### \*args和\*\*kwargs的区别

#### \*args被打包成tuple

#### \*\*kwargs被打包成dict

### 在函数里输入一个变量，这过程中内存发生了什么，哪些值会变化

#### 在python中，变量是存储在内存中的值，也就意味着使用python中的变量会开辟内存空间，python解释器会根据变量类型去开辟不同的内存空间进行变量值的存储，当你的程序需要存储值内容的时候就需要用到变量。

### Python里面的\_\_init\_\_是什么

#### 构造方法类似于类似init()这种初始化方法，来初始化新创建对象的状态，在一个对象被创建以后会立即调用

### Python深拷贝和浅拷贝有什么区别

#### copy.copy()

#### copy.deepcopy()

### Python的垃圾回收机制

#### 引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。

#### 引用计数

#### 标记清除

##### 标记清除（Mark---Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。

###### 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

#### 分代收集

##### Python将内存分为了3"代"，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。

##### 缺点

###### 需要额外的空间维护引用计数

###### 最主要的问题是它不能解决对象的"循环引用"

### python的推导列表了解吗？

#### 一种快速生成list、dict、set的方式。用来替代map、filter等

#### (i for i in range(10))返回生成器

#### \[i for i in range(10) if i % 2 == 0\]

### Python可变/不可变对象

#### bool int float tuple str frozenset不可变集合

#### list set dict

### socket编程中，一个server程序用的最基本的函数，流程是怎么样的

#### 客户端

##### 客户端先创建一个socket对象

##### 客户端socket调用connect() 方法连接远程服务器地址

#### 服务端

##### 服务端先创建一个socket对象

##### 服务端socket将自己绑定到指定IP和端口

##### 服务端socket调用自己的listen()方法

##### 程序不断循环接收来自客户端的连接

### 重载和重写的区别。

#### 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。重载是让类以统一的方式处理不同类型数据的一种手段。

#### 子类不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖

### 接口和抽象类的区别。

### python2/3对比

#### 1、Print函数

##### Py2中，print语句，语句意味着可以直接跟要打印的东西，如何后面接的是一个元祖对象，直接打印。

##### Py3中，print函数，函数就意味着必须要加上括号才能调用，如果接元祖对象，可以接收多个位置参数，并可以打印。

#### 2、输入函数

##### Py2：input\_raw()

##### Py3: input()

#### 3、使用super()的不同

#### 4、除法运算

##### Py2中 '/' 的结果就是一个整数，将小数忽略。即默认地板除 '//' 。

##### Py3中 '/' 的结果是浮点数。但两者 '//' 均是地板除。

#### 5、编码

##### Py2 默认编码是ascii，为了在2中使用中文，需要在文件头部引入coding声明，

##### Py3默认编码是utf-8，可以直接使用中文。

#### 6、字符串

##### Py2：unicode类型表示字符串序列，str类型表示字节序列

##### Py3：str类型表示字符串序列，byte类型表示字节序列

### 装饰器你有了解吗

#### 写个装饰器吧，实现一下输出一个函数运行时间的装饰器

### Python 生成器和迭代器；Python 代码是怎么执行的。

### 面向对象的特性 多态怎么实现的

#### 封装

##### 将细节封装起来提供一个接口被访问，有效地保证了细节的安全。

#### 继承

#### 多态

##### 意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。

##### 一种接口多种实现，实现接口的重用

##### python本来就是多态的，python的变量是没有类型的，只有指向的对象是有类型的，所有方法的调用都是调用对象的方法，不存在不多态的情况

### 异常机制

### 闭包

#### 函数嵌套函数

#### 函数返回函数

#### 函数间有参数引用

## 网络协议

### osi七层模型及每层有哪些协议

#### 应用层

#### 表示层

#### 会话层

#### 传输层

#### 网络层

#### 数据链路层

#### 物理层

### TCP/IP五层

#### 应用层

##### http，ftp，dns，pop3，smtp，rdp

#### 传输层

##### tcp，udp

#### 网络层

##### ARP，IP，icmp，igmp

#### 数据链路层

##### 以太网，ppp，帧中继

#### 物理层

### 浏览器访问web服务器的过程

#### 应用层

##### 浏览器向服务器发送访问网页请求，web服务器向浏览器发送网页，浏览器和服务器之间通信使用http协议，该协议定义了访问网站有哪些方法以及网站响应报文有哪些状态

#### 传输层

##### 网页在传输之前放到缓存，将数据分段后加上传输层首部，传输层首部的格式以及每个字段是为了实现传输层功能，比如可靠传输，流量控制，拥塞避免

##### 添加了传输层首部的tcp协议的数据单元称为数据段，而udp协议的数据单元称为数据报

#### 网络层

##### 数据段想要通过网络发送到浏览器，必须给数据段添加源ip地址和目标ip地址以及网络层首部，以便路由器通过网络层为数据包选择路径

#### 数据链路层

##### 使用集线器组建的网络就是以太网，连接在集线器的计算机使用CSMA/CD协议进行通信

##### 不同的网络数据链路层使用不同的协议，帧格式也不同，路由器在不同网络转发数据包，需要将数据包重新封装

##### 在数据链路层添加数据链路层首部，包括源mac地址，目标mac地址。称为帧

##### 服务器的网卡和路由器以太网接口是数据链路层对等实体

##### 路由器之间链路上没有其他设备，是点到点链路，不需要添加物理地址，使用PPP协议

#### 物理层

##### 服务器将数据包封装成帧后，网卡将数字信号变成电信号传送到网线，称为比特

##### 服务器网卡和路由器以太网接口也是物理层对等实体

### 输入url后的过程

### 发朋友圈的时候图片是怎么上传到服务器的

### tcp

#### 客户端和服务端可以开启多少个tcp连接

##### 根据TCP/IP协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2\^16=65536个,即0-65535,其中0\~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个。但是一台机器最多只能利用28232个端口。

#### TCP通过哪些方法可靠传输

##### 1、合理截断数据包

##### 2、超时重发

##### 3、校验

##### 4、失序重新排序

##### 5、能够丢弃重复数据

##### 6、TCP可以进行流量控制

#### 影响tcp传输速度的因素有哪些

##### 峰值吞吐率

##### 速率抖动

##### 丢包

### http

#### http报文

##### http协议报文格式（请求报文，响应报文）

##### 介绍http报文结构，以及常用的首部有哪些

###### User-Agent

####### 会将创建请求的浏览器和用户代理名称等信息传送给服务器

###### Host

####### 请求资源所在服务器

###### Accept-Language

###### Accept

####### 用户代理能够处理的媒体类型及优先级

###### Connection

###### Cache-Control

####### 控制缓存的行为

###### Accept-Encoding

####### 用户代理支持的内容编码及内容编码的优先级

#### Http如何判断请求已中止

#### get，put方法和post方法的区别

#### HTTP和HTTPS

##### 区别

###### a）https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

###### b）http是超文本传输协议，协议运行在TCP之上，信息是明文传输，https则是具有安全性的ssl加密传输协议，运行在SSL/TLS之上，SSL/TLS运行在TCP之上，信息是加密传输。

###### c）http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

###### d）http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

##### http的缺点

###### 通信使用明文，内容可能被窃听

###### 不验证通信方的身份，有可能遭遇伪装

###### 无法证明报文的完整性，所有有可能已被篡改

#### HTTPS的SSL（TLS）协议

#### http1.0和2.0有什么区别

##### HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级

##### 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

#### 一个http请求的过程

#### cookie和session，token的区别

##### http是无状态链接（无状态是指服务器不知道请求具体来自于哪个用户，因而不能随便去操作数据库），而cookies,session和token就是在这个背景下提出来的。三者都是用来保存用户的相关信息的（如用户标志uid...）、过期时间等，随着客户端的请求发送到服务端用于身份校验。

##### 组成，使用，有效期，优缺点

###### cookies：由服务器生成，在客户端以key-value形式保存用户信息

####### 主要是由Name（名字，相当于key） + Value（值，即当前用户信息） + Domian（域名） + Path（路径） + Expires/Max-Age（过期时间） + Size（大小）

####### 使用：用于响应头和请求头中：由服务器在响应头中设置，客户端保存，并在发送请求时请求头中带上cookie

####### 有效期：如果有设置过期时间，那么只要时间还没过期，即使关闭浏览器cookies也还会存在，反之，会在浏览器关闭时消失

####### 优缺点

######## 优点是可以保存客户相关信息和状态

######## 因为由客户端保存，可以被人修改，而且在传递过程中容易被人拦截(一些重要信息需要通过加密传输，而用session则可以把用户相关信息和状态保存在服务器，所以能避免信息外泄的问题)，具有安全隐患；且在某些浏览器上能保存的cookies数量和大小有限制；还有就是不支持跨域访问(Token可解决这个问题)

###### session：在服务端生成，以key-value形式保存用户信息

####### session保存在服务器内存中，维持一个hash表保存用户相关信息（也是key-value形式）

####### 使用：一个用户对应一个session，每个session都有它独一无二的sessionid，sessionid随响应头set-cookie保存到客户端的cookies中。客户端发送请求时带上cookies，服务端从cookies中拿到sessioid，然后根据sessionid从内存中找到对应用户的session获取相关用户信息

####### 有效期：session默认30分钟超时，即如果在30分钟内session没有被访问过，那么就失效了。

####### 优缺点：能够解决cookies的安全隐患，但因为保存在服务器内存中，当同时访问的用户很多时内存占用争夺，性能会受到影响

######## 如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

###### token：访问令牌--\> 一个服务端生成的独一无二的字符串

####### 组成：登录时由服务端生成，一般组成形式：uuid(用户唯一身份标志)+time（时间戳）+sign(签名=uuid+time+salt根据hash算法生成的字符串）+\[常用的固定参数（可选）\]

####### 使用：服务端生成后随http响应保存在客户端的cookies或local storage中，随客户端请求发送至服务端，用于单点登录的身份验证，防止跨站点请求伪造等

####### 有效期：根据token中的时间戳跟当前时间对比计算，看过期与否，有效期默认7天，用户退出时直接销毁token

####### 优缺点：支持跨域访问，防止信息外泄，可以在多个服务间共享。且不像session存储于服务器内存中，不影响服务器的性能，但是需要额外的时间开销(cpu需要每次去校验传过来的token是否有效

####### Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

####### 基于Token的身份验证

######## 1 客户端使用用户名跟密码请求登录

######## 2 服务端收到请求，去验证用户名与密码

######## 3 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端

######### 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里

######## 4 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token

######## 5 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

##### Cookie和Session的区别

###### 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

###### 2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。

###### 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

###### 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

##### Token 和 Session 的区别

#### https公钥哪里来的

#### HTTPS加密握手的过程，越详细越好，怎么保证安全性

#### htttps 的加密方式（我说了一个ssl，因为没用过，所以也没法细说）

#### https一开始的会话过程

#### 一个完整的 HTTP 请求会涉及到哪些协议？

#### 无状态是指自身不对请求和响应之间的通信状态进行保存。每当有新的请求时，就会有新响应产生，协议本身不保留之前一切请求或响应报文的信息。

### dns

#### DNS是基于什么协议

##### DNS占用53号端口,同时使用TCP和UDP协议。

### 长连接和短链接区别，应用场景

#### 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况

#### 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

#### http 1.0一般就指短连接，smtp,pop3,telnet这种就可以认为是长连接。一般的网络游戏应用都是长连接

### qq是如何针对用户在不同地点或者不同网络状况下登陆时发出异地登陆提醒的，设计出具体的方案

### 用户访问你的服务经过哪些网络协议

### 网络分层，分层的目的，每一层是干啥的，有哪些协议

#### 每层实现特定的功能，每一层有变化不会影响到其他层的更改

#### 程序员只负责解决应用层表示层会话层的问题，不用关心网络问题

### 最大连接数和QPS区别

#### 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。

#### 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。

#### 吞吐量是指系统在单位时间内处理请求的数量。

#### 响应时间是指系统对请求作出响应的时间。

### 网络设备

#### 网卡

##### 二层设备

###### 数据链路层和物理层

#### 集线器

##### 物理层设备

###### 只是将电信号传递到各个接口

#### 交换机

##### 二层设备

###### 根据mac地址转发数据帧

### 数据链路层

#### 同步传输和异步传输

##### 同步

###### 为了保证传输信号的完整性和准确性，要求接收端时钟与发送端时钟保持相同频率，以保证单位时间读取的信号单元数相同

###### 时钟同步信号

###### 以数据帧为单位

##### 异步

###### 以字符为单位

###### 不需要发送时钟同步信号，发送端可以在任意时刻发送数据，接收端随时准备接收数据。如键盘。

##### 区别

###### 异步是面向字符的传输，同步是面向比特的传输

###### 异步传输的单位是字符，同步传输的单位是帧

###### 异步传输通过字符起止的开始码和停止码抓住再同步的机会，而同步传输则是从前同步码中抽取同步信息

###### 异步传输相对于同步传输效率较低

#### 广播信道局域网

##### 链路上不能同时传送多个计算机发送的信号，因为会产生信号叠加相互干扰

##### 带冲突检测的载波侦听多路访问（CSMA/CD）

##### 连接在集线器上的计算机需要通过CSMA/CD通信

#### 网桥，交换机

##### 网桥通过mac地址表对数据帧进行转发

##### 连接在集线器上的设备只能半双工，交换机全双工，不使用CSMA/CD协议

##### 交换机：广播域

###### 一个交换机组成的网络是一个网段

##### 集线器：冲突域

##### 路由器：隔绝广播域

### 网络层

#### 子网掩码

##### 将某个ip地址划分成网络地址和主机地址

#### ip地址分类

##### 主机位全1的地址为广播地址

##### 将子网掩码主机位后移来等长子网划分

#### 路由

##### 网络层功能

###### 由路由器来实现的，为每个ip数据包单独选择转发路径，不负责可靠传输

##### 路由器上有一个路由表，记录到各个网段下一跳该转发给哪个地址

##### 动态路由协议

###### RIP

####### 距离矢量协议

######## 只有到下一跳路由器才知道再下一跳怎么走

###### OSPF

####### 开放最短路径优先协议

######## 能构建网络拓扑

##### TTL

###### 数据包生存时间

####### 没经过一个路由器ttl就减1

##### ARP协议

###### 在计算机和目标计算机通信之前，需要使用该协议解析到目标计算机的mac地址（同一网段通信），或网关的mac地址（跨网段通信）

##### IGMP

###### 组播协议

### 传输层

#### tcp

##### 传输控制协议

###### 从网络上下载一个大文件，需要拆分成多个数据包发送，发送方将要发送的内容一边发送一边放到缓存，需要双方建立连接，协商通信过程中的一些参数，比如一个数据包多少字节

###### 特点

####### tcp是面向连接的，必须建立连接

####### 只能是点对点的（一对一）

####### 提供可靠交付的服务，无差错，不丢失，不重复且按序发送

####### 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据

####### 面向字节流

######## 虽然应用程序和tcp的交互是一次一个数据块，但tcp把应用程序交下来的数据仅仅看成一连串无结构的字节流

######## 只根据对方给出的窗口和当前网络拥塞程度来决定一个报文段应该包含多少字节。如果应用程序传送到tcp缓存的数据太长，tcp就把它划分的短一点再传输。如果太短可以等积累到足够多的字节后再构成报文段发送出去

###### 首部格式

####### tcp报文首部的前20个字节是固定的，因此最小长度是20字节

####### 源端口和目的端口各2个字节

####### 序号4个字节

######## 在tcp连接中传送的字节流的每一个字节都按顺序编号。首部中的序号字段指的是本报文段所发送的数据的第一个字节的序号

####### 确认号4个字节

######## 期望收到对方下一个报文段的第一个数据字节的序号

####### 数据偏移

######## 指出tcp报文段的首部长度

####### 保留

####### 紧急URG

######## 当urg为1时，表明紧急指针字段有效，高优先级

####### 确认ACK

######## 当ack=1时确认号字段才有效

######### 只有建立连接时为0，连接建立后ack=1

####### 推送psh

####### 复位rst

######## 表明tcp连接中出现严重差错，需要重新建立连接

####### 同步syn

######## 在连接建立时用来同步序号

######### syn=1就表示这是一个连接请求或连接请求报文

####### 终止fin

######## 用来释放一个连接，为1时表明此报文的发送发的数据已发送完毕，并要求释放传输连接

####### 窗口

######## 流量控制，接收方目前允许对方发送的数据量

####### 检验和

####### .......

###### 可靠传输

####### 停止等待协议

######## 每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组

######### 效率低

######## 自动重传请求ARQ

####### 改进的停止等待协议：连续ARQ协议和滑动窗口协议

####### 改进的确认

######## 选择确认

######### 只重新发送丢失的包

###### 流量控制

####### 如果发送数据过快，接收方可能来不及接收，造成数据丢失

####### tcp首部会包含客户端的接收窗口大小，服务器就会根据这个客户端的接收窗口大小调整发送窗口大小。在传输过程中，客户端发送的确认数据包，除了确认号号还有窗口信息，服务器收到确认数据包后，会根据窗口信息调整发送窗口。

####### 持续计时器

######## 连接的一方收到对方的零窗口通知，就启动持续计时器

###### 拥塞控制

####### 慢开始和拥塞避免

######## 慢开始

######### 使用慢开始的方法感知网络状态，先发送一个分组，测试一下网络是否拥堵，如果收到确认，再进一步提高发送速度，这就是慢开始。等出现丢包现象，就可以断定网络出现堵塞，放慢增速，这就是拥塞避免

####### 快重传和快恢复

###### 连接管理

####### 三次握手

######## 为什么客户端还要发送一次确认

######### 防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误

######### 客户端发送的第一个连接请求在网络中滞留了，延迟到连接释放以后才到达服务器，服务器就误认为是客户端又发送了一次连接请求

######### 服务器收不到确认就知道客户端并没有要求建立连接

######## 过程

######### 客户端，syn=1，ACK=0，seq=x

######### 服务端，syn=1，ACK=1，seq=y，ack=x+1

######### 客户端，ACK=1，seq=x+1，ack=y+1

######## 状态

######### 客户端

########## closed

########## SYN-SENT

########### 发送出连接请求后

########## ESTABLISHED

########### 收到确认连接报文后

######### 服务端

########## closed

########## listen

########## syn-RCVD

########### 发送确认连接报文后

########## established

####### 四次挥手

######## 过程

######### 客户端，Fin=1，seq=u

########## 客户端进入FIN-wait1

######### 服务端，ACK=1，seq=v，ack=u+1

########## 服务端close-wait

######### 服务端，Fin=1，ACk=1，seq=w，ack=u+1

########## 客户端fin-wait2，服务端last-ACK

######### 客户端，ACk=1，seq=u+1，ack=w+1

########## 客户端time-wait

######## time-wait

######### 等待2MSL

########## 最长报文段寿命，2分钟

######### 为什么

########## 为了保证A发送的最后一个ACK报文段能够到达B。这个报文段有可能丢失，使得处在last-ack状态的B收不到对已发送的FIN-ack报文段的确认。B会超时重传这个FIN-ack报文段，A就可以收到。使得B可以进入close状态

########## 防止已失效的连接请求报文段出现在本连接中。可以使本连接持续时间内的报文段都从网络中消失

######## 保活计时器

######### 客户端已经建立了连接，后来客户端故障，服务器收不到客户发来的数据，需要措施使得服务器不能白白等下去

#### udp

##### 用户数据报协议

###### 用一个数据包就能发送完应用层的全部内容，就使用udp，不需要建立连接

###### 应用

####### 发送短的qq聊天内容

####### 域名解析发送的查询和响应数据包

####### qq语音

####### 多播

###### 特点

####### 无连接的，减少了开销和发送数据前的时延

####### 不保证可靠交付，不用保持连接

####### 面向报文，发送方的udp对应用程序下来的报文，添加首部后就向下交付给网络层

####### 没有拥塞控制，速率恒定

######## 实时应用如ip电话，实时视频会议等

####### 支持一对一，一对多，多对多

####### 首部开销小，只有8字节，tcp20字节

###### 首部格式

####### 源端口

####### 目标端口

####### 长度

####### 检验和

######## 检测udp用户数据报在传输过程中是否有错，有错就丢弃

#### 服务和端口的关系

##### 目标端口定位要访问的服务

#### tcp和udp的区别

##### tcp首部20字节，udp首部8字节

##### tcp只支持一对一，udp支持一对多，多对多，一对一

##### tcp是有连接的，udp不需要建立连接

##### tcp面向字节流，udp面向报文

##### tcp提供可靠传输，udp不可靠

##### udp没有拥塞控制

### 应用层

#### DNS

##### 过程

###### client向B服务器（net，顶级域名服务器）发送域名解析请求

###### B服务器只负责net域名解析，将请求发送给根服务器，根服务器将com服务器ip发送给B

###### B将域名解析请求发送给C。C查询到三级域名的ip地址返回给B

###### B将域名解析请求发送给E，三级域名服务器E将ip地址返回给B

###### B将ip地址返回给client，并将结果缓存到本地。非授权应答。client缓存结果

###### client2也需要解析www.soho.com，B将结果返回给client2

#### Telnet

##### 远程终端协议，可以进行远程管理

#### http

##### 超文本传输协议

###### 是客户端浏览器与web服务器之间的应用层通信协议

##### URL

###### 统一资源定位符

####### 用来表示从因特网上得到的资源位置和访问这些资源的方法

##### http1.0和1.1比较

###### 1.0

####### 浏览器和服务器只保持短暂连接，每次请求都要与服务器建立一个tcp连接

####### 每次建立和关闭连接比较耗时，并且影响服务器和客户端的性能

###### 1.1

####### 支持持续连接

######## 非流水线方式

######### 客户在收到前一个响应后才能发出下一个请求

######## 流水线方式

######### 客户在收到http的响应报文之前就能够接着发送新的请求报文

##### 请求报文和响应报文

###### 请求报文

####### 请求行

######## 方法

######### get

########## 请求获取request-url所标识的资源

######### post

########## 在request-url所标识的资源后附加新的数据，提交表单

######### put

########## 请求服务器存储一个资源

######### ......

######## 请求资源的url

######## http的版本

####### 首部行

####### 实体主体

###### 响应报文

####### 网页状态码

######## 1XX

######### 信息性状态码

########## 接收的请求正在被处理

######## 2XX

######### 成功状态码

########## 请求正常处理完毕

######### 200

########## 请求成功

######### 204

########## 请求成功，但是没有结果返回

######### 206

########## 客户端请求一部分资源，服务端成功响应，返回一部分资源

######## 3XX

######### 重定向状态码

########## 需要进行附加操作以完成请求

######### 301

########## 永久性重定向

######### 302

########## 临时性重定向

######## 4XX

######### 客户端错误状态码

########## 服务器无法处理请求

######### 404

########## 服务器上无法找到请求的资源

######### 401

########## 需要认证或者认证失败

######### 403

########## 请求被服务器拒绝了

######## 5XX

######### 服务器错误状态码

########## 服务器处理请求出错

######### 500

########## 服务端执行请求时发生了错误

######### 503

########## 服务器正在超负载或者停机维护，无法处理请求

##### http是面向文本的

##### cookie

###### 服务器存放在客户端的通行证。将用户的身份保存到客户端

#### ftp协议

##### 文本传输协议

### URI和URL的区别

#### uniform resource identifier，统一资源标识符，用来标识唯一的一个资源。

##### 访问资源的命名机制

##### 存放资源的主机名

##### 资源本身的名称，由路径表示，着重强调于资源

##### 比如：

###### 身份证

#### 是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何定位这个资源。

##### 存有该资源的主机IP地址

##### 主机资源的具体地址

##### URL是URI的子集

##### 比如：

###### 动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人

#### URI用字符串标识某一互联网资源

#### URL表示资源的地点

### get和post区别

#### GET把参数包含在URL中，POST通过request body传递参数

##### GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息

#### GET在浏览器回退时是无害的，而POST会再次提交请求。

#### GET请求会被浏览器主动cache，而POST不会，除非手动设置。

##### GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

#### GET请求只能进行url编码，而POST支持多种编码方式。

#### GET请求在URL中传送的参数是有长度限制的，而POST么有

#### 对参数的数据类型，GET只接受ASCII字符，而POST没有限制

#### GET产生一个TCP数据包；POST产生两个TCP数据包

##### 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

##### 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

#### HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 

##### HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。

### put和post

#### PUT和POST都有更改指定URI的语义.但PUT被定义为idempotent的方法，POST则不是.idempotent的方法:如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。

#### PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

#### Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

## 操作系统

### 第一章

#### 操作系统的运行机制、体系结构

##### 运行机制

###### 两种指令（cpu能识别、 执行的最基本命令）

####### 特权指令

######## 只能在核心态下执行

####### 非特权指令

###### 两种处理器状态 用程序状态字寄存器（psw）中 的某个标志位来标识当前处理器 处于什么状态，如0位用户态，1为 核心态。

####### 用户态（目态）

######## 此时cpu只能执行非特权指令

####### 核心态（管态）

######## 特权指令、非特权指令都可以执行

###### 两种程序

####### 内核程序

######## 是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态

####### 应用程序

######## 为了保证系统安全运行，不允许执行特权指令，运行在用户态

##### 操作系统内核（计算机配置的底层软件，是操作系统最基本最核心的部分。实现操作系统内核功能的那些程序就是内核程序）

###### 时钟管理

####### 实现计时功能

###### 中断处理

####### 负责实现中断机制

###### 原语（设备驱动、cpu切换等）

####### 是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性（要么不执行，要么就执行完），运行时间短，调用频繁

###### 对系统资源进行管理的功能（有的归入内核有的没有）

####### 进程管理

####### 存储器管理

####### 设备管理

##### 操作系统体系结构

###### 大内核

####### 将操作系统的主要功能模块都作为系统内核，运行在核心态

####### 优点：高性能

####### 缺点：内核代码庞大，结构混乱，难以维护

###### 微内核

####### 只把最基本的功能保留在内核

####### 优点：内核功能少，结构清晰，方便维护

####### 缺点：需要频繁的在核心态和用户态之间切换，性能低

#### 中断和异常

##### 中断机制的诞生

###### 实现了多道程序并发执行。 本质：发生中断就意味着需要操作系统介入，开展管理工作

##### 中断的概念和作用

###### 1、当中断发生时，cpu立即进入核心态； 2、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理； 3、对于不同的中断信号，会进行不同的处理

###### 由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此cpu需要从用户态转为核心态。中断可以使cpu从用户态切换为核心态，是操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行。

###### 用户态到核心态是通过中断实现的，且是唯一途径。

###### 核心态到用户态的切换是通过执行一个特权指令，将程序状态字的标志位设置为"用户态"

##### 中断的分类 本质区别：信号来源

###### 内中断（也称为"异常"） 来源：cpu内部，与当前执行的指令有关

####### 自愿中断------指令中断 如系统调用时使用的访管指令

####### 强迫中断

######## 硬件故障 缺页

######## 软件中断 如整数除0

###### 外中断 cpu外部，与当前指令无关

####### 外设请求 如I/O操作完成发出的中断信号

####### 人工干预 如用户强行终止一个进程

##### 外中断的处理过程

###### 1、每条指令执行结束后，cpu检查是否有外部中断信号； 2、若有外部中断信号，则需要保护被中断进程的cpu环境； 3、根据中断信号类型转入相应的中断处理程序； 4、恢复原进程的cpu环境并退出中断，返回原进程继续往下执行

#### 系统调用 是操作系统提供给应用程序使用的接口 系统调用的相关处理需要在核心态下进行

##### 操作系统为用户和计算机之间的接口

###### 命令接口（允许用户直接使用）

####### 联机命令接口：用户说一句，系统做一句

####### 脱机命令接口：用户说一堆，系统做一堆

###### 程序接口（允许用户通过程序间接使用）：由一组系统调用组成

##### 操作系统为什么要提供系统调用功能： 比如打印店，如果各个进程可以随意使用打印机，会导致打印出的东西混在一起。

###### 解决方法：操作系统提供系统调用功能，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统发出请求。操作系统会对各个请求进行协调管理

##### 按功能分类

###### 设备管理

####### 完成设备的请求/释放/启动 等功能

###### 文件管理

####### 完成文件的 读/写/创建/删除 等功能

###### 进程控制

####### 完成进程的 创建/撤销/阻塞/唤醒 等功能

###### 进程通信

####### 完成进程之间的消息传递/信号传递 等功能

###### 内存管理

####### 完成内存的 分配/回收 等功能

##### 系统调用背后的过程

###### 1、传递系统调用参数； 2、执行陷入指令； 3、执行系统调用相应服务程序； 4、返回用户程序

###### 1、陷入指令是在用户态执行的，执行陷入指令之后会立即引发一个内中断，从而cpu进入核心态； 2、发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行； 3、陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令

### 第二章 CPU

#### 进程的定义、组成、组织方式、特征

##### 进程的定义

###### 程序段、数据段、PCB（进程控制块，用来描述进程的各种信息如程序代码存放位置）三部分组成了进程实体，一般简称进程。创建/撤销进程，实质上是创建/撤销进程实体中的PCB

###### PCB是进程存在的唯一标识

###### 定义：是程序的一次执行过程； 是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

###### 进程实体和进程是不一样的：进程实体是静态的，进程则是动态的

##### 进程的组成

###### PCB

####### OS通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息

######## 进程描述信息

######## 进程控制和管理信息

######## 资源分配清单

######## 处理机相关信息

###### 程序本身的运行所需的数据

####### 程序段

######## 程序代码存放在此

####### 数据段

######## 程序运行时使用、产生的运算数据

##### 进程的组织 （讨论的是多个进程之间的组织方式问题）

###### 链接方式

####### 按照进程状态将PCB分为多个队列，优先级高的放在队头

####### 操作系统持有指向各个队列的指针

###### 索引方式

####### 根据进程状态不同，建立几张索引表

####### 操作系统持有指向各个索引表的指针

##### 进程的特征

###### 动态性 （进程最基本的特征）

####### 进程是程序的一次执行过程，是动态地产生、变化和消亡的

###### 并发性

####### 内存中有多个进程实体，各进程可并发执行

###### 独立性 进程是资源分配、接受调度的基本单位

####### 进程是能独立运行、独立获得资源、独立接受调度的基本单位

###### 异步性 （会导致并发程序执行结果的不确定性）

####### 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"进程同步机制"来解决异步问题

###### 结构性

####### 每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

#### 进程的状态与转换

##### 状态

###### 三种基本状态

####### 运行状态

######## 占有CPU，并在CPU上运行

######## 在单核处理机环境下，每一个时刻最多只有一个进程处于运行态

######## CPU✅其他所需资源✅

####### 就绪状态

######## 已经具备运行条件，但由于没有空闲CPU，而暂时不能运行

######## 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立刻进入运行态开始运行

######## CPU❌其他所需资源✅

####### 阻塞状态

######## 因等待某一事件而暂时不能运行

######## 如等待操作系统分配打印机、等待读磁盘操作的结果。

######## CPU❌其他所需资源❌

###### 创建状态

####### 进程正在被创建，操作系统为进程分配资源、初始化PCB

###### 终止状态

####### 进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

##### 进程状态间的转换

###### 就绪态------》运行态

###### 运行态------》就绪态

###### 运行态------》阻塞态

####### 进程自身做出的主动行为

###### 阻塞态------》就绪态

####### 被动行为

###### 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）

###### 创建态------》就绪态

####### 系统完成创建进程相关的工作

###### 运行态------》终止态

####### 进程运行结束，或运行过程中遇到不可修复的错误

#### 进程控制

##### 基本概念

###### 什么是进程控制

####### 对系统中的所有进程实施有效的管理。就是要实现进程状态转换

###### 如何实现进程控制

####### 用原语实现 原语特点：原子性

######## 采用关中断指令、开中断指令实现，只允许在核心态下执行的特权指令

##### 进程控制相关的原语

###### 进程的创建

###### 进程的终止

###### 进程的阻塞，阻塞和唤醒要成对出现

###### 进程的唤醒

###### 进程的切换

###### 无论哪个原语要做的无非三件事： 1、更新PCB中的信息 2、将PCB插入合适的队列 3、分配/回收资源

#### 进程通信

##### 什么是进程通信

###### 进程之间的信息交换

###### 为了保证安全，一个进程不能直接访问另一个进程的地址空间

##### 通信方式

###### 共享存储 两个进程对共享空间的访问必须是互斥的

####### 基于数据结构的共享

######## 比如共享空间里只能放一个长度为10的数组，速度慢，限制多

####### 基于存储区的共享

######## 在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统

###### 消息传递

####### 进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的"发送消息/接受消息"两个原语进行数据交换

####### 方式

######## 直接通信方式

######### 消息直接挂到接受进程的消息缓冲队列上

######## 间接通信方式

######### 消息要先发送到中间实体

###### 管道通信

####### 是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区

####### 只能采用半双工通信，若要实现双向同时通信，则要设置两个管道

####### 各进程要互斥地访问管道

####### 数据以字节流的形式写入管道，当管道写满时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。

####### 如果没写满，就不允许读。如果没读空，就不允许写。

####### 数据一旦被读出，就从管道中被抛弃，意味着读进程最多只有一个，否则可能会有读错数据的情况

#### 线程概念和多线程模型

##### 什么是线程，为什么引入线程

###### 有的进程可能需要同时做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了线程，来增加并发度

###### 引入线程后，线程成为了程序执行流的最小单位

###### 线程是一个基本的cpu执行单元，也是程序执行流的最小单位

###### 引入线程后，进程内的各线程之间也可以并发

###### 进程只作为除cpu之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）

##### 引入线程机制后，有什么变化

###### 资源分配、调度

####### 传统进程机制中，进程是资源分配、调度的基本单位

####### 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位

###### 并发性

####### 传统进程机制中，只能进程间并发

####### 引入线程后，各线程间也能并发，提升了并发度

###### 系统开销

####### 传统的进程间并发，需要切换进程的运行环境，系统开销很大

####### 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

####### 引入线程后，并发所带来的系统开销减小

##### 线程有哪些重要的属性

###### 线程是处理机调度的单位

###### 多cpu计算机中，各个线程可占用不同的CPU

###### 每个线程都有一个线程ID、线程控制块（TCB）

###### 线程也有就绪、阻塞、运行三种基本状态

###### 线程几乎不拥有系统资源

###### 同一进程的不同线程间共享进程资源

###### 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预

###### 同一进程中的线程切换，不会引起进程切换

###### 不同进程中的线程切换，会引起进程切换

###### 切换同进程内的线程，系统开销小

###### 切换进程，系统开销较大

##### 线程的实现方式

###### 用户级线程

####### 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）

####### 用户级线程中，线程切换可以在用户态下即可完成，无需系统干预

####### 在用户看来是有多个线程，但是在操作系统内核看来，并意识不到线程的存在。

####### 用户级线程就是从用户的视角能看到的线程

###### 内核级线程

####### 线程管理工作由操作系统内核完成。

####### 内核级线程的切换必须在核心态下才能完成

####### 从操作系统内核视角能看到的线程

####### 操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位

######## 例如：一个进程有两个内核级线程，三个用户级线程，即使在4核处理机的计算机里运行，也最多只能分配到两个核，最多只有两个用户线程并行执行

##### 多线程模型 由几个用户级线程映射到几个内核级线程的问题引入

###### 多对一模型

####### 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

####### 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

###### 一对一模型

####### 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行

####### 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

###### 多对多模型

####### 克服了多对一模型并发度不高的缺点，有克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点

#### 处理机调度的概念、层次

##### 基本概念

###### 进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。

###### 处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

##### 三个层次

###### 高级调度（作业调度）

####### 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此需要确定某种规则来决定将作业调入内存的顺序

####### 按照一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等资源，并建立相应的资源，建立相应的进程（PCB），以使它们获得竞争处理机的权利

####### 是外存与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB

####### 是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机是作业运行结束才调出

###### 中级调度（内存调度）

####### 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存

####### 目的是为了提高内存利用率和系统吞吐量

####### 暂时调到外存等待的进程状态为挂起状态。PCB不会一起调到外存，而是常驻内存。PCB会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控管理。被挂起的进程PCB会被放到挂起队列中。

####### 中级调度就是要决定哪个处于挂起状态的进程重新调入内存

####### 一个进程可能被多次调出、调入内存，因此中级调度的频率比高级的高

###### 低级调度（进程调度）

####### 其主要任务是按照某种方法和策略从就绪队列中选择一个进程，将处理机分配给它

####### 是操作系统中最基本的一种调度

##### 三层调度的联系、对比

###### 高

####### 调度发生在：外存------》内存

######## 对进程状态的影响：无------》创建态------》就绪态

###### 中

####### 外存------》内存

######## 挂起态------》就绪态

###### 低

####### 内存------》CPU

######## 就绪态------》运行态

##### 补充知识

###### 进程的"挂起态"

####### 和阻塞的区别，两种状态都是暂时不能获得CPU的服务，但是挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中

###### 七状态模型

#### 进程调度的时机、切换与过程、调度方式

##### 时机

###### 什么时候需要进程调度

####### 当前运行的进程主动放弃处理机

######## 进程正常终止

######## 运行过程中发生异常而终止

######## 进程主动请求阻塞（如等待I/O）

####### 当前运行的进程被动放弃处理机

######## 分给进程的时间片用完

######## 有更紧急的事要处理（如I/O中断）

######## 有更高优先级的进程进入就绪队列

###### 什么时候不能进行进程调度

####### 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换

####### 进程在操作系统内核程序临界区中

######## 临界资源：一个时间段内只允许一个进程使用的资源，各进程要互斥地访问临界资源

######## 临界区：访问临界资源的那段代码

######## 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）

####### 在原子操作过程中

##### 切换与过程

###### 狭义的调度与切换的区别

####### 广义的进程调度包含了选择一个进程和进程切换两个步骤

###### 进程切换的过程需要做什么

####### 对原来运行进程各种数据的保存

####### 对新的进程各种数据的恢复

####### 进程切换是有代价的，如果过于频繁，会使得整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少

##### 方式

###### 非剥夺调度方式（非抢占式）

####### 只能由当前运行的进程主动放弃CPU

###### 剥夺调度方式（抢占式）

####### 可由操作系统剥夺当前进程的CPU使用权

#### 调度算法的评价指标

##### CPU利用率

###### CPU处于忙碌的时间占总时间的比例

##### 系统吞吐量

###### 单位时间内完成作业的数量

##### 周转时间

###### 周转时间、平均周转时间

####### 从作业被提交给系统开始，到作业完成为止的这段时间间隔

####### 包括四个部分

######## 作业在外存后备队列上等待作业调度（高级调度）的时间

######## 进程在就绪队列上等待进程调度（低级调度）的时间

######## 进程在CPU上执行的时间

######## 进程等待I/O操作完成的时间

####### 周转时间=作业完成时间---作业提交时间

####### 平均周转时间=各作业周转时间之和/作业数

###### 带权周转时间、平均带权周转时间

####### 带权周转时间=作业周转时间/作业实际运行的时间

##### 等待时间

###### 对于进程来说，指进程处于等待处理机状态时间之和。在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间

###### 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间

##### 响应时间

###### 从用户提交请求到首次产生响应所用的时间

#### 调度算法

##### 先来先服务（FCFS）

##### 短作业服务（SJF）

##### 高响应比优先（HRRN）

##### 时间片轮转

##### 优先级调度

##### 多级反馈队列

#### 进程同步、互斥

##### 什么是进程同步

###### 就是讨论怎么解决进程异步的问题

###### 也称直接解约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

##### 什么是进程互斥

###### 也称间接制约关系，指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源

###### 可在逻辑上分四个部分

####### 进入区

####### 临界区

####### 退出区

####### 剩余区

###### 进入区和退出区是负责实现互斥的代码段

###### 需要遵循以下原则

####### 空闲让进

######## 临界区空闲时，应允许一个进程访问

####### 忙则等待

######## 临界区正在被访问时，其他试图访问的进程需要等待

####### 有限等待

######## 要在有限时间内进入临界区，保证不会饥饿

####### 让权等待

######## 进不了临界区的进程，要释放处理机，防止忙等待

#### 进程互斥的软件实现方法

##### 单标志法

##### 双标志先检查

##### 双标志后检查

##### peterson算法

#### 进程互斥的硬件实现方法

##### 中断屏蔽方法

##### TestAndSet（TS指令/TSL指令）

##### Swap指令（XCHG指令）

#### 信号量机制

##### 分类

###### 整型信号量

####### 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量

######## P

######### 如果资源数不够，就一直循环等待

######### 如果资源数够，则占用一个资源

######## V

######### 使用完资源后，在退出区释放资源

####### 缺陷：存在忙等

###### 记录型信号量

##### 信号量其实就是一个变量，可以用信号量表示系统中某种资源的数量

##### wait(s)和signal(s)原语，信号量s

###### 常简称为P、V操作

###### 检查和上锁一气呵成，避免了并发和异步导致的问题

#### 用信号量机制实现进程互斥、同步、前驱关系

#### 生产者消费者问题

##### 问题描述

###### 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。产品可以是数据。

##### 生产者和消费者共享一个初始为空，大小为n的缓冲区。

##### 只有缓冲区没满时生产者才能把产品放入缓冲区，否则等待。只有缓冲区不空时，消费者才能取产品，否则等待

##### 缓冲区是临界资源，各进程必须互斥访问

##### 实现互斥的P操作一定要在实现同步的P操作之后

#### 多生产者多消费者问题

#### 吸烟者问题

#### 读者-写者问题

#### 哲学家进餐问题

#### 管程

##### 为什么要引入管程

###### 一种高级同步机制

##### 管程的定义和基本特征

#### 死锁

##### 什么是死锁

###### 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都被阻塞，都无法向前推进的现象，就是死锁

##### 进程死锁、饥饿、死循环的区别

###### 死锁

####### 各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都被阻塞，都无法向前推进的现象

######## 一定是"循环等待对方手里的资源"导致的，至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态

###### 饥饿

####### 由于长期得不到想要的资源，某进程无法向前推进的现象

######## 可能只有一个进程发生饥饿。发生饥饿的进程即可能是阻塞态（如长期得不到需要的I/O设备）也可能是就绪态（长期得不到处理机）

###### 死循环

####### 某进程执行过程中一直跳不出来某个循环的现象，bug导致，也可能是程序员故意设计

######## 可能只有一个进程发生死循环。死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题

##### 死锁产生的必要条件

###### 互斥条件

####### 只有对必须互斥使用的资源的争抢才会导致死锁

###### 不可剥夺条件

####### 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放

###### 请求和保持条件

####### 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放

###### 循环等待条件

####### 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

####### 发生死锁时一定有循环等待，但是发生循环等待时未必死锁。是死锁的必要不充分条件

##### 什么时候会发生死锁

###### 对系统资源的竞争

###### 进程推进顺序非法

###### 信号量的使用不当也会造成死锁

####### 实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁

##### 死锁的处理策略

###### 预防死锁

####### 破坏死锁产生的四个必要条件中的一个或几个

###### 避免死锁

####### 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）

###### 死锁的检测和解除

####### 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁

#### 死锁的处理

##### 不允许死锁发生

###### 静态策略：预防死锁

####### 破坏互斥条件

######## 将临界资源改造为可共享使用的资源（spooling技术）

######## 缺点：可行性不高，很多时候无法破坏互斥条件

####### 破坏不可剥夺条件

######## 方案一：申请的资源得不到满足时，立即释放拥有的所有资源

######## 方案二：申请的资源被其他进程占用时，有操作系统协助剥夺（考虑优先级）

######## 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿

####### 破坏请求和保持条件

######## 运行前分配好所有需要的资源，之后一直保持

######## 缺点：资源利用率低；可能导致饥饿

####### 破坏循环等待条件

######## 给资源编号，必须按编号从小到大的顺序申请资源

######## 缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦

###### 动态策略：避免死锁

####### 什么是安全序列

######## 就是指如果系统按照这种序列分配资源，则每个进程都能顺序完成。只要找出一个安全序列，系统就是安全状态，一定不会发生死锁

####### 什么是系统的不安全状态，与死锁有何关系

######## 如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有的进程都无法顺序的执行下去。如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。

####### 如何避免系统进入不安全状态------银行家算法

######## 可以在资源分配之前先预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是银行家算法的核心思想

######## 可以把单维的数字拓展为多维的向量

##### 允许死锁发生

###### 死锁的检测和解除

####### 检测

######## 数据结构：资源分配图

######### 两种结点

########## 进程结点

########## 资源结点

######### 两种边

########## 进程结点------》资源结点（请求边）

########## 资源结点------》进程结点（分配边）

######## 死锁检测算法

######### 依次消除与不阻塞进程相连的边，直到无边可消

######### 注：所谓不阻塞进程是指其申请的资源数还足够的进程

######### 死锁定理：若资源分配图是不可完全简化的，说明发生了死锁

########## 用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程

####### 解除

######## 方法

######### 资源剥夺法

########## 挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程

######### 撤销进程法

########## 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。代价很大

######### 进程回退法

########## 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点

######## 如何决定对谁动手

######### 进程优先级

######### 已执行多长时间

######### 还要多久能完成

######### 进程已经使用了多少资源，优先牺牲拥有更多资源的进程

######### 进程是交互式的还是批处理式的，优先牺牲批处理式的

### 第三章 内存

#### 内存的基础知识

##### 什么是内存，有何作用

###### 存储单元

####### 1字节

###### 内存地址

####### 比如4GB内存，即2\^32次方个字节，如果按字节编址的话，就是2\^32个小房子，需要地址需要用32个二进制位来表示

####### 一个内存地址对应一个存储单元

###### 用于存放数据的硬件。程序执行前需要先放到内存中才能被cpu处理

##### 进程运行的基本原理

###### 指令的工作原理

###### 逻辑地址 vs 物理地址

####### 相对地址又称逻辑地址

####### 绝对地址又称物理地址

###### 从写程序到程序运行：编辑---编译---链接---装入

####### 编译

######## 由编译程序将用户源代码编译成若干个目标模块（就是把高级语言翻译成机器语言）

####### 链接

######## 由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块

######### 链接后形成完整的逻辑地址

####### 装入

######## 由装入程序将装入模块装入内存运行

###### 三种链接方式

###### 三种装入方式

####### 绝对地址

######## 编译时产生绝对地址

####### 可重定位装入

######## 装入时将逻辑地址转换为物理地址

####### 动态运行时装入

######## 运行时将逻辑地址转换为物理地址，需设置重定位寄存器

######### 现代操作系统

#### 内存管理的概念

##### 内存空间的分配与回收

###### 连续分配管理方式

####### 单一连续分配

######## 内存被分为系统区和用户区

######### 系统区

########## 通常位于内存的低地址部分

########## 存放操作系统相关数据

######### 用户区

########## 存放用户进程相关数据

########## 内存中只能有一道用户程序，用户程序独占整个用户区空间

####### 固定分区分配

######## 将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业

######## 分区大小相等

######## 分区大小不等

####### 动态分区分配

######## 在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。系统分区的大小和数量是可变的

######## 空闲分区表

######## 空闲分区链

######## 内部碎片

######### 分配给某进程的内存区域中，有些部分没有用上

######## 外部碎片

######### 是指内存中的某些空闲分区由于太小而难以利用

######## 无内部碎片，有外部碎片

######## 动态分区分配算法

######### 在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

###### 非连续分配管理方式

####### 基本分页存储管理

######## 基本分页存储管理的基本概念

######### 把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

######### 将内存空间分为一个个大小相等的分区，每个分区就是一个页框，页框号从0开始

######### 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为页或页面，页号也是从0开始

######### 为了方便计算页号、页内偏移量，页面大小一般要为2的整数幂

######### 页号= 逻辑地址/页面长度（取除法的整数部分）

######### 页内偏移量 = 逻辑地址 % 页面长度（取余）

######### 为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表

########## 页号和块号组成

########## 记录进程页面和实际存放的内存块（页框）之间的对应关系

####### 基本分段存储管理

####### 基本段页式存储管理

###### 连续分配是指为用户进程分配的必须是一个连续的内存空间

##### 内存空间的扩充

###### 覆盖技术

####### 解决程序大小超过物理内存总和的问题

####### 思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存

####### 内存中分为一个固定区和若干个覆盖区

####### 需要常驻内存的段放在固定区中，调入后就不再调出（除非运行结束）。不常用的放在覆盖区，需要用到时调入内存，用不到时调出内存

###### 交换技术

####### 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）

####### 覆盖是在同一个程序或进程中的

####### 交换是在不同进程（或作业）之间的

###### 虚拟存储技术

##### 地址转换

###### 把逻辑地址转为物理地址

##### 存储保护

###### 保证各进程在各自存储空间内运行，互不干扰

#### 虚拟内存的基本概念

##### 传统存储管理方式的特征、缺点

##### 局部性原理

###### 时间局部性

####### 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量循环）

###### 空间局部性

####### 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

###### 高速缓存技术

####### 将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中

##### 虚拟内存的定义和特征

###### 可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行

###### 在程序执行过程中，当访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序

###### 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

###### 在操作系统的管理下，在用户看来似乎是有一个比实际内存大得多的内存，这就是虚拟内存

###### 三个特征

####### 多次性

######## 无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存

####### 对换性

######## 在作业运行时无需一直常驻内存，而是允许作业在运行过程中，将作业换入换出

####### 虚拟性

######## 从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

##### 如何实现虚拟内存技术

###### 请求分页存储管理

####### 操作系统要提供

######## 请求调页功能，将缺失的页面从外存调入内存

######## 页面置换功能，将暂时不用的页面换出外存

####### 页表机制

####### 缺页中断机构

####### 地址变换机构

###### 请求分段存储管理

###### 请求段页式存储管理

##### 页面置换算法 页面的换入、换出需要磁盘I/O、会有较大的开销，因此好的页面置换算法应该追求更少的缺页率

###### 用页面置换算法决定应该换出哪个页面

###### 五种

####### 最佳置换算法（OPT）

######## 每次选择淘汰的页面将是以后永远不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率

####### 先进先出置换算法（FIFO）

######## 每次选择淘汰的页面是最早进入内存的页面

####### 最近最久未使用置换算法（LRU）

######## 每次淘汰的页面是最近最久未使用的页面

######## 实现方法

######### 赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

####### 时钟置换算法（CLOCK）

####### 改进型的时钟置换算法

##### 页面分配策略

###### 驻留集

####### 指请求分页存储管理中给进程分配的物理块的集合

###### 页面分配、置换策略

####### 固定分配局部置换

####### 可变分配全局置换

####### 可变分配局部置换

###### 调入页面的时机

###### 从何处调页

###### 抖动现象

###### 工作集

### 问题

#### activity生命周期

#### 进程和线程

##### 进程通信方式

##### 线程有哪些状态

##### 进程和线程的区别

##### 怎么避免发生死锁

##### 同步和互斥，锁

##### 主线程切换到子线程的方法

##### 线程的通信方式

###### 线程同步的方法

##### 孤儿进程；僵尸进程，怎么预防，怎么解决。

###### 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程

###### 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中

##### 操作系统进程调度有哪些算法

##### 进程fork子进程，两个进程占用内存情况

##### 新建一个线程消耗的资源

##### 线程状态

###### 未命名管道和命名管道区别

##### fork出来的子进程和父进程有哪些共享的东西

###### 什么情况下用fork

##### 协程和线程的区别

##### 什么是线程安全

##### 守护、僵尸、孤儿进程的概念

##### 进程调度方式

##### 进程上下文

#### 介绍共享内存通信方式

#### LRU在操作系统怎么实现？

#### 阻塞 IO 和非阻塞 IO；异步 IO。

#### linux操作系统讲讲

#### 一台服务器美一个小时会有一段内存高峰期，怎么判断是什么问题

#### 未命名管道和命名管道区别

#### 讲讲共享内存

#### 简述一下什么是死锁，死锁出现的原因（这个简单）

#### 滑动窗口是什么，干什么用的

#### 死锁的四个条件

#### 虚拟内存

#### 同步和互斥的区别

#### 同步与异步

#### 用户态和内核态的区别

#### select，poll，epoll

##### 与多进程和多线程相比，I/O多路复用技术最大的优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，减小了不必要的上下文切换，降低了系统的开销。

###### I/O多路复用就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符就绪(一般就是读就绪或者写就绪)，能够通知程序进行相应的读写操作。

##### select

###### select由用户进程调用

####### select函数监控的文件描述符分为3类，分别是可读、可写或者异常，调用后select函数会阻塞用户进程，直到有文件描述符就绪，用户进程再将数据从kernel拷贝到用户进程

###### 时间复杂度O(n)

##### poll

###### poll和select本质上没有区别，他没有最大连接数的限制，因为它的fd使用链表来存储的。

###### 时间复杂度O(n)

##### epoll

###### epoll在linux内核中申请一个简单的文件系统

###### 把原先的select/poll调用分成了三个部分：

####### 调用epoll\_create()建立一个epoll对象（在文件系统中为这个对象分配资源）

####### 调用epoll\_ctl向epoll对象中添加这100万个连接的套接字

####### 调用epoll\_wait收集发生事件的连接

###### epoll没有采取轮询的方式而是采取回调的方式，当相应事件发生时通知程序进行IO操作。事件驱动的

####### select，poll都是采取轮询的方式

###### 时间复杂度O(1)

## 手撕

### 给定一个无序数组，求最大连续的数列长度，要求时间复杂度越短越好

### 最长公共子序列

### 一串字符串，有字母有数字，找出里面的最大

### 一串无序的数字，如何找出缺失的最小正整数

### 从N个数中找出第K大的数

### 无序数组的中位数

### 给一数组，让你找一对满足i`<j && a[i]<a[j]的i和j>`{=html}

#### 给一数组，让你找一对满足i`<j<k && a[i]<a[j]<a[k] 的i和j和k>`{=html}

### 求2的平方根，精度0.00001

### 最大岛问题

### 股票利润3（可以买卖两次）

### 手撕代码，提到了装饰器，那来你写个装饰器吧，实现一下输出一个函数运行时间的装饰器

### 用定长列表实现队列

### 写一下二叉树节点之间最大距离

### 两个文件里存了很多网址，怎么找出两个文件里共有的网址

### 给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。

### 写topk

### 删除注释。

### 找只出现一次的数字，其他都出现两次；

### 给一个数组，四个数和加减乘除组成表达式，求所有值为给定值的表达式。

### 图的广度优先遍历

### 给一个乱序数组，输出每一个数字后面第一个比它大的数字（单调栈）

### 数组和链表实现一个hashmap，实现get，put方法，resize功能。

### 一个数据先递增再递减，找出数组不重复的个数，比如 \[1, 3, 9, 1\]，结果为3，不能使用额外空间，复杂度o(n)

### 高考成绩2000万数据，分数0-700，如何快速知道你的排名，如何知道任一分数排名，刚开始想到按照快排思路进行查找，后来想到桶排序

### 两个链表，可能相交，找出相交的节点，给出证明

### 给定m个不重复的字符 \[a, b, c, d\]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3

### 写一个统计函数耗时的函数，不用装饰器

### 蛇皮走位层次遍历二叉树、二维数组排序

### 一百万个整数，找最大100个

### n个整数，找最大m个，用堆的话时间复杂度多少？

### 旋转后的排序数组（没有重复值），找某个数

### 将二叉树编程双向链表

### 单例模式实现

#### 如果发生了多并发 同时访问这个单例 会怎么样

### 二叉树的公共祖先

#### 不用递归怎么做

#### 写出找出路径的算法

### 二叉树中和为某一值的路径

### 给出一个二进制串和一个整数k，k表示可以将串中的任意k个0换成1，求变换完后能形成的最大连续1串的长度

### 假如要统计访问频次前10的用户，怎么操作？（哈希表存次数，最小堆求TOP-K），分析整个过程的时间、空间复杂度？

### 反转域名

### 求一个二叉树所有叶子节点的父节点之和

### 实现链表对折相加

### 判断一个字符串是否是点分十进制的ipv4格式

### 给定一个二叉树，判断它是否是高度平衡的二叉树

### 长度为n的数组中，每个元素的范围是0\~n-1，求是否出现重复的数

### 一个升序排列（允许有相等元素）的链表，将最后一个元素指向开头元素形成一个环。现在任意给出一个环中的节点引用，并给定整数K，要求实现一个insert函数，将K插入到合适的位置上

### 剑指offer原题和已整理的题

#### 两个链表的第一个公共节点

#### 手撕快排

#### 无重复字符串的最长子串

#### 手写单例模式-懒汉模式

#### 股票利润1

#### 写pow(x,n)

#### 实现一个栈时间复杂度O(1) 可以push（），pop（），getmin（）

#### 跳台阶

#### 给一个数组（正负数都有），让你找最大子数组的和。

## 算法

### 说说你知道的排序算法？（接着问各种排序算法稳不稳定）

#### 冒泡排序

##### 

###### 稳定

#### 选择排序

##### 

###### 不稳定

#### 插入排序

#### 希尔排序

#### 快速排序

##### 递归

##### 非递归

#### 归并排序

#### 堆排序

##### 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

##### 堆位于二级缓存，栈位于一级缓存

### 二分查找

### 稳定性

#### 稳定排序算法会让原本有相等键值的纪录维持相对次序

### 常见排序算法效率比较

### 算法

#### 分治

##### 通过把问题分解为更小的子问题，先解决小问题，再把小问题的解合并起来的一种方法。

#### 动态规划

##### 大规模问题的答案可以由小规模问题的答案递推得到

##### (1).建立状态转移方程

##### (2).缓存并复用以往结果

##### (3).按顺序从小往大算

#### 贪婪

##### 每一阶段做决策都找出当前条件下的最优解

## mysql

### 知识点 引用cyc2018

#### Mysql服务器逻辑架构图

#### 索引

##### B+树

###### B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

###### 操作

####### 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

####### 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

###### 与红黑树比较

####### （一）更少的查找次数

######## 平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

######## 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

####### （二）利用磁盘预读特性

######## 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

######## 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

##### B树

###### B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

##### MYSQL索引

###### 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

###### B+树索引

####### 是大多数 MySQL 存储引擎的默认索引类型。

####### 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

####### 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

####### InnoDB 的 B+Tree 索引

######## 主索引

######### 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引

######### 因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

######## 辅助索引

######### 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

###### 哈希索引

####### 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

######## 无法用于排序与分组；

######## 只支持精确查找，无法用于部分查找和范围查找。

####### InnoDB 存储引擎有一个特殊的功能叫"自适应哈希索引"，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

###### 全文索引

####### MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

####### 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

####### 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

####### InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

###### 空间数据索引

####### MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

####### 必须使用 GIS 相关的函数来维护数据。

##### 索引优化

###### 独立的列

####### 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

####### 例如下面的查询不能使用 actor\_id 列的索引：

######## SELECT actor\_id FROM sakila.actor WHERE actor\_id + 1 = 5;

###### 多列索引

####### 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor\_id 和 film\_id 设置为多列索引。

######## SELECT film\_id, actor\_ id FROM sakila.film\_actor WHERE actor\_id = 1 AND film\_id = 1;

###### 索引列的顺序

####### 让选择性最强的索引列放在前面。

######## 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

######## 例如下面显示的结果中 customer\_id 的选择性比 staff\_id 更高，因此最好把 customer\_id 列放在多列索引的前面。

######### SELECT COUNT(DISTINCT staff\_id)/COUNT(\*) AS staff\_id\_selectivity, COUNT(DISTINCT customer\_id)/COUNT(\*) AS customer\_id\_selectivity, COUNT(\*) FROM payment;

######### staff\_id\_selectivity: 0.0001 customer\_id\_selectivity: 0.0373 COUNT(\*): 16049

###### 前缀索引

####### 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

######## 前缀长度的选取需要根据索引选择性来确定。

###### 覆盖索引

####### 索引包含所有需要查询的字段的值。

####### 优点

######## 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。

######## 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。

######## 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

##### 索引的优点

###### 大大减少了服务器需要扫描的数据行数。

###### 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。

####### groupby

######## 使用group by 的目的就是要将数据分类汇总

####### order by是按字段排序

###### 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

##### 索引的使用条件

###### 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；

###### 对于中到大型的表，索引就非常有效；

###### 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

#### 查询性能优化

##### 使用 Explain 进行分析

###### Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

###### 比较重要的字段有：

####### select\_type : 查询类型，有简单查询、联合查询、子查询等

####### key : 使用的索引

####### rows : 扫描的行数

##### 优化数据访问

###### 减少请求的数据量

####### 只返回必要的列：最好不要使用 SELECT \* 语句。

####### 只返回必要的行：使用 LIMIT 语句来限制返回的数据。

####### 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

###### 减少服务器端扫描的行数

####### 最有效的方式是使用索引来覆盖查询。

##### 重构查询方式

###### 切分大查询

####### 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

###### 分解大连接查询

####### 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

#### 存储引擎

##### InnoDB

###### 是 MySQL 默认的事务型存储引擎

###### 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

####### Read Uncommitted（读取未提交内容）

######## 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。

####### Read Committed（读取提交内容）

######## 一个事务只能看见已经提交事务所做的改变

####### Repeatable Read（可重读）

######## 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行

####### Serializable（可串行化）

######## 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

######## 简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

###### 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

###### 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

###### 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

##### MyISAM

###### 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

###### 提供了大量的特性，包括压缩表、空间数据索引等。

###### 不支持事务。

###### 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

####### 共享锁（S锁）：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

######## 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

####### 排他锁（X锁）：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。

###### 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

###### 如果指定了 DELAY\_KEY\_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

##### 比较

###### 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

###### 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

###### 外键：InnoDB 支持外键。

###### 备份：InnoDB 支持在线热备份。

###### 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

###### 其它特性：MyISAM 支持压缩表和空间数据索引。

#### 数据类型

##### 整型

##### 浮点数

##### 字符串

###### 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

##### 时间和日期

#### 切分

##### 水平切分

###### 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

###### 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

###### 策略

####### 哈希取模：hash(key) % N；

####### 范围：可以是 ID 范围也可以是时间范围；

####### 映射表：使用单独的一个数据库来存储映射关系。

##### 垂直切分

###### 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

###### 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

#### 复制

##### 主从复制

###### binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。

###### I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。

###### SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

##### 读写分离

###### 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

###### 读写分离能提高性能的原因在于：

####### 主从服务器负责各自的读和写，极大程度缓解了锁的争用；

####### 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；

####### 增加冗余，提高可用性。

###### 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

### 提问

#### 数据库索引

##### 介绍下数据库的索引以及作用

###### 索引是为了加快查找速度的一种数据结构。

###### 高效查找数据。

##### 数据库索引有哪些类型

###### B+树索引

###### 全文索引

###### 哈希索引

###### 空间数据索引

##### 全文索引跟其他索引的区别，怎么实现的

###### 用于查找文本中的关键词，而不是直接比较是否相等

###### 查找条件使用match against，而不是where

###### 全文索引使用倒排索引实现，记录着关键词到其所在文档的映射

##### Mysql的索引怎么实现的

###### 虽说MyISAM与InnoDB的数据结构都是B+树，但是其实现方式缺截然不同：https://www.jianshu.com/p/2db75d5f5732

####### MyISAM

######## 索引文件与数据文件分开，叶子节点存储的是数据行的内存地址

######## 如需要建立辅助索引，则辅助索引的叶节点存储的也是数据行的内存地址，

######## MyISAM这种索引的方式也叫非聚簇索引。

####### InnoDB

######## InnoDB的索引文件就是数据文件，叶子节点存储的就是真实数据

######## 若想建立辅助索引，叶子节点存储的是就是主键，

######## InnoDB的这种索引又叫聚簇索引

######### 所以不建议使用过长的字段作为主键，这样会使得辅助索引变得过大

#### 数据库的存储引擎，介绍一下，以及其数据结构

##### innoDB了解吗

##### 介绍一下innodb存储引擎，对比其他存储引擎优点是什么

##### innodb索引数据结构，深入问复合主键索引的数据结构是否有不同

#### 数据库的事务

##### 事务的特点

##### MySQL隔离级别

##### 事务隔离级别的实现

#### 数据库联合索引ABC，分别查AB,AC,BC，问哪些查找能用到索引？

##### 最左前缀匹配原则，abc 建索引的时候是基于先 a，然后基于 b 、c 有序的，查询时候想走上索引得也按照这个顺序，bc 是走不上索引的

#### B-树和B+树区别

##### 讲一讲b+树

###### B+树其实和B树是非常相似的，我们首先看看相同点。

####### 根节点至少一个元素

####### 非根节点元素范围：m/2 \<= k \<= m-1

###### 不同点

####### B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。

####### 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。

####### 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。

####### 父节点存有右孩子的第一个元素的索引。

##### 为什么要用b+树

###### 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。

###### 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。

###### 所有的叶子节点形成了一个有序链表，更加便于查找。

#### MySQL索引、b+树，为什么不用哈希map来存储？

#### 最左前缀原则

##### 如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。

###### 索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。

#### 版本号怎么唯一，说了利用数据库自增id，太慢，接着说了雪花算法，还有其他吗，说了zookeeper，可是我不会这个...

#### 为什么需要新建表，有什么字段，新建表后可能出现什么问题（查询关联表过多）

#### 那如何解决关联表过多（给关联表增加相应索引，引入redis）

#### 查询平均年龄前三的男子的年龄和所在城市

#### mysql 有哪些锁，如何加锁

##### MySQL乐观锁

###### 如何使用乐观锁

#### 数据库的主键索引和普通索引的区别，哪个查询更快

##### 主键查询效率比索引更快。因为索引有很多种，不能保证都是唯一的。主键必须是唯一的

##### 主键通常使用聚簇索引。普通索引保存的是主键的地址，然后再根据主键去查询，所以要检索两次，主键索引只需要检索一次就性了

#### 索引是越多越好吗，索引建多了会有什么问题，对什么操作有影响

##### 数据库表的维护会变得困难，尤其是大型分区表，在整理数据时（比如删除一个分区），非常、非常的耗时。

##### 当索引不覆盖分区表达式时，就必须建全局索引。

###### 我猜考官的意思也是，少建全局索引。

#### 如何实现可重复读

#### SQL：联表查询2个表中工号为"123"的人的所有信息

#### 主键外键的了解

##### 外键

###### 是用于建立和加强两个表数据之间的链接的一列或多列

###### 外键约束主要用来维护两个表之间数据的一致性

##### 主键

###### 能够唯一标识表中某一行的属性或属性组

#### 数据库事务的隔离级别有哪些？Mysql默认的隔离级别？不同的隔离级别是通过什么实现的？mysql的explain有用过吗？讲一讲数据库的慢查询？数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适？什么时候用悲观锁呢？

#### 非关系数据库和关系数据库区别

##### 1. 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2. 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。关系型数据库的优势：1. 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。2. 事务支持使得对于安全性能很高的数据访问要求得以实现。

##### Nosql没有行、列的概念，用Key-Value的形式来存储数据

#### 悲观锁和乐观锁

##### 悲观锁

###### 当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制

###### 具有强烈的独占和排他特性

###### 悲观锁主要是共享锁或排他锁

####### 共享锁又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。

####### 排他锁又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。

##### 乐观锁

###### 乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

###### 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

##### 乐观锁并未真正加锁（给表加一个版本号字段），效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。

##### 悲观锁依赖数据库锁，效率低。更新失败的概率比较低。

##### 数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适？什么时候用悲观锁呢？

###### 悲观锁

####### 多写

###### 乐观锁

####### 适用于多读少写的场景

### 慢查询

#### 超过指定时间的SQL语句查询称为慢查询

### 左连接右连接

## redis

### 问题

#### 缓存一致性问题

##### 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。

##### 

##### 读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。

###### 1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。

###### 2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

##### 解决方案

###### 更新DB时总是不直接触碰DB，而是通过代码。而代码做的显式更新DB，然后马上del掉redis里的数据。

###### Redis里的数据不立刻更新，等redis里数据自然过期。然后去DB里取，顺带重新set redis。

###### 读取db，把最新的数据塞给Redis。可以监听数据的binlog来更新redis

#### 缓存穿透和缓存雪崩

##### 缓存穿透

###### 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

####### 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

###### 解决方案

####### 布隆过滤器

######## 首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。

####### 缓存空对象

######## 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

##### 缓存雪崩

###### 设置缓存时采用了相同的过期时间，导致缓存在某一个时刻同时失效，或者缓存服务器宕机宕机导致缓存全面失效，请求全部转发到了DB层面，DB由于瞬间压力增大而导致崩溃

###### 解决

####### 搭建高可用集群

####### 数据加热

######## 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

####### 限流降级

#### 减库存过程，为什么不先减库存再查询是否存在订单

#### 减库存命令，redis 如何保证这个命令原子性（redis的单线程模型）

#### 如果有一个用户发起大量请求，这个他第一个请求还没有写入数据库，也就是他可以一直减库存，如何解决？一开始想的是接口限流，但是面试官说现在要对某个用户限流怎么办，在面试官提示下说了用redis来记录用户访问次数

#### redis分布式锁，实现过程，命令，可能出现的问题

##### 为了保证解锁操作的原子性，我们用LUA脚本完成这一操作。先判断当前锁的字符串是否与传入的值相等，是的话就删除Key，解锁成功。

##### SET key value \[NX\|XX\] \[EX\|PX\] seconds

###### NX 代表只在键不存在时，才对键进行设置操作。

###### PX 5000 设置键的过期时间为5000毫秒。

#### 布隆过滤器

#### 如果要实现一个redis的排行榜，可以用到哪种数据结构

##### 用sorted-set实现一个排行榜需要注意哪些问题（我觉得是并列问题的解决，面试官说对的）

#### Redis 的使用场景

#### zset 延时队列怎么实现的

##### 将消息序列化成一个字符串作为zset的value

##### 这个消息的到期处理时间作为score

##### 然后用多个线程轮训zset获取到期的任务进行处理

#### Redis 的 ZSET 做排行榜时，如果要实现分数相同时按时间顺序排序怎么实现？ 说了一个将 score 拆成高 32 位和低 32 位，高 32 位存分数，低 32 位存时间的方法。问还有没有其他方法，想不出了

##### long 分数，二进制用高 32位存 等级，低32位存时间（秒精度）

##### long 整数长度总共有 19位，923XXX.......，时间戳 毫秒精度 是 13位，所以只需 14 \~ 19 位存 等级，其他13位存时间

#### 让你设计一个延时任务系统怎么做 说了两个方案，一个是使用 redis 的 ZSET 来实现，考虑分片来抗高并发，使用 redis 的持久化来实现落地，使用 redis 的哨兵实现故障转移。 一个是使用时间轮的方法。

#### 让你设计一个限流的系统怎么做？ 令牌桶

#### Reids为什么这么快？

##### 1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。

##### 2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。

##### 3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。

##### 4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。

##### 5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。

#### 多线程IO的模型

### redis设计与实现总结

#### 第一部分 数据结构与对象

##### 键值对

###### 数据库的键总是一个字符串对象

###### 数据库的值可以是五种对象的一种

##### 数据结构

###### 简单动态字符串SDS

####### SDS和C字符串的区别

######## 常数复杂度获取字符串长度

######## 杜绝缓冲区溢出

######## 减少修改字符串时带来的内存重分配次数

######### 空间预分配

########## 小于1m，分配和len属性同样大小的未使用空间

########## 大于1m，分配1m

######### 惰性空间释放

######## 二进制安全

######## 兼容部分C字符串函数

###### 链表

###### 字典

####### 字典的实现

######## 使用哈希表作为底层实现

######### 一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对

######### 哈希表

########## 由dictht结构定义

########### table

############ 是一个数组，数组中每个元素都是一个指向dictentry结构的指针，每个dictentry结构保存着一个键值对

########### size

########### sizemask

########### used

########## 哈希表节点

########### dictentry结构

############ key

############ value

############ next

############# 指向另一个哈希表节点的指针，形成链表。这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突问题

######## 字典

######### 由dict结构表示

########## type

########## privdata

########## ht属性

########### 是一个包含两个项的数组，数组中每个项都是一个dictht哈希表。字典只使用ht\[0\]哈希表，ht\[1\]只会在对ht\[0\]进行rehash时使用

########## rehashidx

########### 如果没有在rehash，值为-1

######## 哈希算法

######### 程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面

######## 解决键冲突

######### 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突

######### next属性

########## 单向链表

########### 总是将新节点添加到链表的表头位置

######## rehash

######### 当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行扩展或收缩

######### 步骤

########## 为字典的ht\[1\]分配空间

########## 将保存在ht\[0\]中的所有键值对放置到ht\[1\]上。rehash指的是重新计算键的哈希值和索引值

########## 当ht\[0\]包含的所有键值对都迁移到ht\[1\]时，释放ht\[0\]，将ht\[1\]设置为ht\[0\]，并在ht\[1\]新创建一个空白哈希表

######### 渐进试rehash

########## 分多次、渐进式完成

########## 每次对字典进行操作时

###### 跳跃表

####### 是一种有序的数据结构

######## 通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的

######## 查找复杂度

######### 平均O（lgn），最坏O(N)

####### 实现

######## 由zskiplistNode和zskiplist两个结构定义

######### zskiplist

########## header

########### 指向跳跃表的表头

########## tail

########### 指向表尾

########## level

########### 层数最大的那个节点的层数

########## length

########### 记录跳跃表的长度（跳跃表节点的数量）

######### zskiplistNode

########## 层level

########### 每个层都有两个属性

############ 前进指针

############# 用于访问位于表尾方向的其他节点

############ 跨度

############# 前进指针所指向节点和当前节点的距离

############# 用来计算排位的

############## 在查找某个节点的过程中，将沿途访问过的所有层的跨度累加起来，就是目标节点在跳跃表中的排位

########### 层的数量越多，访问其他节点的速度越快

########## 后退backward

########### 指向位于当前节点的前一个节点

########## 分值score

########### 在跳跃表中，节点按分值从小到大排列

########## 成员对象

########### 节点所保存的成员对象

####### 有序集合的底层实现之一

######## 如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，作为有序集合的底层实现

###### 整数集合

####### 是集合键的底层实现之一

######## 当一个集合只包含整数值元素，并且集合元素的数量不多时，redis就会使用整数集合作为集合键的底层实现

###### 压缩列表

####### 是列表键和哈希键的底层实现之一

######## 当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么就是长度比较短的字符串，就会用压缩列表作为列表键的底层实现

####### 由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值

##### 对象

###### 五种

####### 字符串

####### 列表

######## 编码可以是ziplist和linkedlist（双端链表实现）

######## 所有字符串元素长度小于64字节；列表元素数量小于512个

######### 使用ziplist

########## 否则双端链表

####### 哈希

######## 编码可以是ziplist或者hashtable

######## 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；哈希对象保存的键值对数量小于512个

######### 使用ziplist

########## 否则hashtable编码（字典作为底层实现）

####### 集合

######## 编码可以是intset或者hashtable

######## 集合对象保存的所有元素都是整数值；集合对象保存的元素数量不超过512个

######### 使用intset编码

########## hashtable编码

####### 有序集合

######## 编码可以是ziplist或者skiplist

######## 有序集合保存的元素数量小于128个；保存的元素成员长度都小于64字节

######### 使用ziplist

########## 否则使用skiplist

###### 每个对象都是由一个redisObject结构表示

####### type

####### encoding

####### ptr

######## 指向底层实现数据结构的指针

######## 由编码决定

####### lru属性

######## 记录对象最后一次被命令程序访问的时间

#### 第二部分 单机数据库的实现

##### 数据库

###### 所有数据库都保存在db数组中，db数组的每一项都是一个redisDb结构，每个redisDb结构代表一个数据库

###### 默认创建16个数据库

###### 切换数据库

####### 客户端的db指针指向redisserver.db数组的其中一个元素。被指向的元素就是客户端的目标数据库

###### 数据库键空间

####### redisDb结构的dict字典保存了数据库中的所有键值对，称这个字典为键空间

##### 设置键的生存时间或过期时间

###### 通过expire或者pexpire命令或者setex

###### 设置过期时间

####### expire

######## ttl秒

####### pexpire

######## ttl毫秒

####### expireat

######## 过期时间设置为timestamp所指定的秒数时间戳

####### pexpireat

######## 毫秒数时间戳

######## 其他三个都是由pexpireat实现的

###### 保存过期时间

####### redisDb中的expires字典保存了数据库中所有键的过期时间，称这个字典为过期字典

######## 过期字典的键是一个指针，指向键空间中的某个键对象

###### 移除过期时间

####### persist

###### 过期键的判定

####### 检查给定键是否存在于过期字典；如果存在取得键的过期时间

####### 检查unix时间戳是否大于键的过期时间

###### 过期键删除策略

####### 定时删除

######## 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

######## 对内存友好，对cpu不友好

######### 在过期键比较多时，占有cpu资源

####### 惰性删除

######## 放任过期键不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期，就删除。如果没有，返回该键

######## 对cpu时间来说是最友好的，对内存不友好

######### 过期键没有被访问到，永远不会删除，内存泄漏

####### 定期删除

######## 每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键

######## 前面两者的折衷

######## 难点

######### 确定删除操作执行的时长和频率

###### redis的过期删除策略

####### 使用的是惰性删除和定期删除

###### 过期键对持久化的影响

####### 生成RDB文件

######## 已过期的键不会被保存在RDB中

####### 载入RDB文件

######## 如果以主服务器模式运行，过期的键不会被载入到数据库中

####### AOF文件写入

######## 追加一条del命令

####### AOF重写

######## 程序会检查，已过期的键不会保存到重写后的AOF文件中

####### 复制

######## 主服务器在删除一个键时，会向从服务器发送del命令

##### RDB持久化

###### redis是内存数据库，将自己的数据库状态存储在内存中。

####### rdb持久化可以将某个时间点的数据库状态保存到磁盘中，防止数据丢失

###### RDB文件是一个经过压缩的二进制文件

###### RDB文件的创建与载入

####### SAVE

######## 阻塞redis服务器进程，直到RDB文件创建完毕，服务器不能处理任何请求

####### BGSAVE

######## 派出一个子进程，由子进程负责创建RDB文件，服务器父进程继续处理命令请求

####### RDB文件的载入工作是在服务器启动时检测到RDB文件存在，就会自动载入

######## 载入过程中，服务器一直处于阻塞状态

####### 优先使用AOF

###### 自动间隔性保存

####### 满足以下三个条件之一，BGSAVE命令就会被执行

######## save 900 1

######## save 300 10

######## save 60 10000

####### dirty计数器

######## 记录上一次执行RDB持久化命令后，服务器对数据库状态进行了多少次修改

####### lastsave属性

######## 记录了上一次成功执行持久化命令的时间，unix时间戳

###### RDB文件结构

##### AOF持久化

###### 将服务器所执行的写命令保存下来

###### 持久化的实现

####### 三个步骤

######## 命令追加

######### 每执行一个命令，就会以协议格式将写命令追加到aof\_buf缓冲区的末尾

######## 文件写入

######### 服务器在每次结束一个事件循环之前，都会考虑是否需要将缓冲区的内容写入和保存到AOF文件中

######## 文件同步

####### AOF文件的载入与数据还原

######## 服务器只要重新执行一遍AOF文件里面的写命令就会还原服务器关闭之前的数据库状态

######## 步骤

######### 创建伪客户端

########## redis命令只能在客户端上下午执行

######### 从AOF文件中读取一条写命令

######### 使用伪客户端执行写命令

######### AOF文件的写命令是否全部执行完毕

######### 载入完毕

###### AOF重写

####### 为了解决AOF文件体积膨胀

######## 服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态相同，但新的文件不会包含任何浪费空间的冗余命令，所以体积更小

####### AOF后台重写

######## 因为redis服务器使用单个线程来处理命令请求，在写入操作中，服务器将无法收到处理客户端发来的请求

######### 所以将重写程序放到子进程里执行

######## 为了解决数据不一致问题

######### AOF重写缓冲区

########## 服务器执行完一个写命令时，会将命令发送给AOF缓冲区和AOF重写缓冲区

########## AOF缓冲区的内容会定期被写入到AOF文件中

########## 当重写工作完成之后，会把AOF重写缓冲区的写命令写入到新的AOF文件中

######### 重写期间服务器进程执行以下三个动作

########## 执行客户端发来的命令

########## 将写命令追加到AOF缓冲区

########## 追加到AOF重写缓冲区

##### 事件

###### redis服务器是一个事件驱动程序

####### 文件事件

######## 服务器和客户端通过套接字连接，文件事件就是服务器对套接字操作的抽象

######## 虽然文件事件处理器以单线程方式运行，但是通过使用IO多路复用程序来监听多个套接字，文件事件即实现高性能的网络通信模型

######## 构成

######### 套接字

######### io多路复用程序

########## 总是会将套接字放到队列中，通过队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字

######### 文件事件分派器

######### 事件处理器

####### 时间事件

######## 服务器的一些操作需要在给定的时间点执行，时间事件就是服务器对这类定时操作的抽象

######## 服务器将所有的时间事件放在一个无序链表中，每当时间事件执行器运行时，就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器

##### 客户端

###### 一对多服务器程序

####### 通过io多路复用技术实现的文件事件处理器，redis服务器使用单线程单进程来处理命令请求，并与多个客户端进行网络通信

#### 第三部分 多机数据库的实现

##### 通过slaveof或者设置slaveof选项让一个服务器去复制另一个服务器。被复制的服务器称为主服务器，对主服务器进行复制的称为从服务器

##### 复制

###### 旧版复制功能的实现

####### 复制功能分为两个操作

######## 同步

######### 用于将从服务器的数据库状态更新至主服务器当前状态

######### 步骤

########## 从服务器向主服务器发送SYNC命令

########## 主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令

########## rdb文件生成后，主服务器会将文件发送给从服务器，从服务器载入

########## 主服务器将缓冲区里面的写命令发送给从服务器，从服务器执行

######## 命令传播

######### 在主服务器数据库状态被修改，导致主从服务器状态不一致时，让主从服务器重新回到一致状态

######### 在同步操作执行完毕后，主从服务器数据库状态将一致。但不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的状态会被修改，导致主从服务器数据库状态再次出现不一致

########## 主服务器需要对从服务器执行命令传播操作

########### 主服务器会将自己执行的写命令发送给从服务器

####### 缺陷

######## 在redis2.8之前，从服务器对主服务器的复制有两种情况

######### 初次复制

########## 以前没有复制过主服务器

######### 断线后重复制

########## 处于命令传播阶段的主从服务器因为网络中断了复制，但从服务器通过自动重连连接上了主服务器，并继续复制主服务器

########### 效率低

########## 旧版的断线后主服务器又重新生成rdb文件

########### sync命令是一个非常耗资源的操作

############ 生成rdb文件需要占用cpu、内存和磁盘io资源

############ 主服务器发送rdb文件需要网络资源

############ 从服务器载入时，会因为阻塞而无法处理命令请求

####### 新版

######## 使用psync命令代替sync命令

######### 具有完整重同步和部分重同步两种模式

########## 完整重同步用于处理初次复制情况

########## 部分重同步用于处理断线后重复制情况

########### 主服务器将连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些命令就行了

###### 部分重同步的实现

####### 复制偏移量

######## 通过对比主从服务器的复制偏移量，就可以知道主从服务器是否一致

####### 复制积压缓冲区

######## 是由主服务器维护的一个固定长度的FIFO队列，默认大小是1MB

######## 在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会放到复制积压缓冲区中

######### 保存一部分最近传播的写命令，并且会为队列中每个字节记录相应的复制偏移量

####### 服务器的运行id

###### 复制的实现

####### 设置主服务器的地址和端口

####### 建立套接字连接

####### 发送ping命令

######## 检查主服务器能否正常处理命令请求

####### 身份验证

####### 发送端口信息

######## 从服务器向主服务器发送从服务器的监听端口号

####### 同步

####### 命令传播

###### 心跳检测，每秒一次

####### 检测主从服务器的网络连接状态

####### 辅助实现min-slaves选项

####### 检测命令丢失

##### 哨兵

###### 是redis高可用性解决方案

####### 由一个或多个哨兵实例组成的哨兵系统可以监听任意多个主服务器，以及从服务器，并且在主服务器下线时，自动将下线服务器属下的从服务器升级为新的主服务器

###### 当主服务器下线时长超过用户设定的下线时长时，哨兵系统会对主服务器进行故障转移操作

####### 哨兵挑选主服务器下的一个从服务器，将其升级为主服务器

######## 领头哨兵会将已下线主服务器的所有从服务器保存到一个列表里面，按照以下规则进行过滤

######### 删除列表中所有处于下线或者断线状态的从服务器

######### 删除列表中所有最近五秒内没有回复过领头哨兵的INFO命令的从服务器

######### 删除所有与已下线主服务器连接断开超过一定时间的从服务器

######### 之后将根据从服务器的优先级，对列表中的剩余从服务器进行排序，选出优先级最高的

######### 如果有多个优先级相同的，就按照从服务器的复制偏移量排序

######### 如果有多个优先级最高，复制偏移量最大的从服务器，则按照ID排序

####### 哨兵系统向主服务器属下的所有从服务器发送新的复制命令，让他们成为新的主服务器的从服务器

####### 哨兵系统还会监视已下线的server1，在他重新上线时，将其设置为从服务器

#### 第四部分 独立功能的实现

##### 事务

###### multi

###### exec

###### watch

####### 是一个乐观锁，可以在exec命令执行之前，监视任意数量的数据库键，并在exec命令执行时，检查被监视的键是否至少有一个已经被修改，如果是，服务器将拒绝执行事务，并向客户端返回事务执行失败的空回复

###### 事务的ACID性质

####### 原子性

######## 数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行

####### 一致性

######## 如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该是一致的

######### 一致指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据

####### 隔离性

######## 即使数据库中有多个事务并发的执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同

######## redis使用单线程的方式执行事务，并且服务器保证在执行事务期间不会对事务进行中断，因此，redis的事务总是以串行的方式运行的

####### 耐久性

######## 当一个事务执行完毕时，执行这个事务所得的结果已经被保存到了永久性存储介质里面了，即使服务器执行完停机了，执行事务的结果也不会丢失

###### 事务提供了一种或多个命令请求打包，然后一次性、按顺序执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他命令请求

## 数据结构

### 知道哪些数据结构

### 二叉树的概念，知道几种二叉树，二叉搜索树查询的时间复杂度

#### 完全二叉树

##### 对于一颗二叉树，假设其深度为d(d\>1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;

#### 二叉搜索树

##### 当为线性时O(n)，平均O（logn）

#### 平衡二叉树

##### 当且仅当任何节点的两棵子树的高度差不大于1的二叉树

### 输出二叉树的右视图

### hashmap

#### 介绍下hashmap

#### hashmap原理

#### hashmap中链表的优化

#### 讲一下hashmap的数据结构（数组链表红黑树逐级扩展）

#### hashmap查找的时间复杂度（O（1））

#### hashmap 的转换过程（初始值16 然后翻倍，然后链表长度超过8转红黑树）

#### 哈希表解决冲突的方法有哪些

### AVL特点原理，红黑树特点原理

### 讲一下数组和链表和区别

### 栈和队列。

#### 队列先进先出，栈先进后出

#### 栈只能在一端插入和删除，队列只能在一端插入，另一端删除

#### 遍历数据速度不同，栈只能从头部取数据，最先放入的需要遍历整个栈最后才能取出，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性

##### 队列基于地址指针进行遍历，可以从头部或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历过程中不影响数据结构，速度更快

### 如何判断一个图是否有环

### 红黑树

#### https://www.jianshu.com/p/e136ec79235c

#### 性质

##### 性质1：每个节点要么是黑色，要么是红色。

##### 性质2：根节点是黑色。

##### 性质3：每个叶子节点（NIL）是黑色。

##### 性质4：每个红色结点的两个子结点一定都是黑色。

##### 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。

###### 如果一个结点存在黑子结点，那么该结点肯定有两个子结点

#### 自平衡

##### 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。

##### 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。

##### 变色：结点的颜色由红变黑或由黑变红。

#### 插入

##### 红黑树为空树

###### 直接把插入节点作为根节点，并设为黑色

##### 插入节点的key已存在

###### 把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。

##### 插入结点的父结点为黑结点

###### 由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。

##### 插入结点的父结点为红结点

###### 如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。

###### 场景

####### 叔叔结点存在并且为红结点

######## 祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。

######## 可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。

######## 试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是唯一一种会增加红黑树黑色结点层数的插入情景。

####### 叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点

######## 叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。

### 二叉树

#### 前序遍历

#### 中序遍历

#### 后序遍历

#### 广度优先

## linux

### linux常用命令

#### linux查看内存，cpu占用命令？

##### top查看cpu占用

###### top -b -n 1 -d 3 \>\>file.txt 解析： -b ：batch模式，可以重定向到文件中 -n 1：一共取1次top数据。后边加数字，表示次数 -d 3：每次top时间间隔是3秒钟

####### -p 进程pid

##### free -m查看内存占用

###### free是显示的当前内存的使用,-m的意思是M字节来显示内容.

##### vmstat 3(间隔时间) 100(监控次数)

###### 使用vmstat，查看CPU和内存占用情况

###### vmstat 命令报告关于线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息

#### 端口占用命令？

##### netstat -anp \| grep 3366

###### 查看特定端口3366的进程

##### lsof -i:3366

###### 查看某个端口是否被占用

###### 查看端口属于哪个程序

##### linux下通过进程名查看其占用端口：

###### 1、先查看进程pid

####### ps -ef \| grep 进程名

###### 2、通过pid查看占用端口

####### netstat -nap \| grep 进程pid

#### 查看进程pid

##### ps -ef\|grep tomcat 查看所有有关tomcat的进程

##### ps aux 是用BSD的格式来显示

###### ps -ef 是用标准的格式显示进程的

#### 压缩文件

##### tar -czf

##### 解压

###### tar -xvzf

#### 查看文件头10行

##### head -n 10 example.txt

#### 查看文件后10行

##### tail -n 10 example.txt

#### 查找文件

##### find / -name filename.txt 根据名称查找/目录下的filename.txt文件

###### 文件名称符合 name 的文件。iname 会忽略大小写

##### 将目前目录其其下子目录中所有一般文件列出

###### find . -type f

##### 将目前目录及其子目录下所有延伸档名是 c 的文件列出来。

###### find . -name "\*.c"

##### linux 下查找大于100M的文件

###### find . -type f -size +100M

#### du

##### du -sh \[dirname\|filename\]

###### 当前目录或文件的大小：

####### du -sh .

###### 显示前10个占用空间最大的文件或目录：

####### du -s \* \| sort -nr \| head

##### -s选项指定对于目录不详细显示每个子目录或文件的大小

#### 排序

##### sort

###### 按ASCII码值进行比较，最后将他们按升序输出。

#### awk

##### awk '{\[pattern\] action}' {filenames} \# 行匹配语句 awk '' 只能用单引号

###### awk '{print \$1,\$4}' log.txt

####### 每行按空格或TAB分割，输出文本中的1、4项

##### awk -F \#-F相当于内置变量FS, 指定分割字符

##### awk -v \# 设置变量

###### awk -v a=1 '{print \$1,\$1+a}' test.txt

##### awk -f {awk脚本} {文件名}

###### 过滤第一列大于2的行

####### awk '\$1\>2' log.txt

###### 过滤第一列等于2的行

####### awk '\$1==2 {print \$1,\$3}' log.txt

###### 过滤第一列大于2并且第二列等于'Are'的行

####### awk '\$1\>2 && \$2=="Are" {print \$1,\$2,\$3}' log.txt

#### wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。

#### 文本计数

##### 找出某一个单词的出现频率

###### cat file \| grep -o word \| wc -l

###### grep -o test word \| wc -l

####### 其中 -o 表示"only-matching"，即"仅匹配"之意

######## 比如下面有一条文本 tmp.txt ，其中内容为： {"aid":45,"path":"attachment/Mon\_1112/2\_1\_5728040df3ab346.jpg"} 我们想从中过滤出 aid 的值即 45 ，那么可以先如下这么做： grep -o -e 'aid":\[1-9\]\*' tmp.txt 得到的结果为：aid":45

###### more file \| grep -o word \| wc -l

##### 统计这个文件中出现次数最多的前10个单词。

###### cat words.txt \| sort \| uniq -c \| sort -k1,1nr \| head -10

####### uniq -c: 显示唯一的行，并在每行行首加上本行在文件中出现的次数

####### sort -k1,1nr: 按照第一个字段，数值排序，且为逆序

####### head -10: 取前10行数据

#### 查看 CPU 的命令和磁盘 IO 的命令

##### iostat

#### linux 系统里，一个被打开的文件可以被另一个进程删除吗？

##### 学操作系统原理的时候，我们知道，linux是通过link的数量来控制文件删除，只有当一个文件不存在任何link的时候，这个文件才会被删除。

##### 而每个文件都会有2个link计数器-- i\_count 和 i\_nlink。i\_count的意义是当前使用者的数量，也就是打开文件进程的个数。i\_nlink的意义是介质连接的数量；或者可以理解为 i\_count是内存引用计数器，i\_nlink是硬盘引用计数器。再换句话说，当文件被某个进程引用时，i\_count 就会增加；当创建文件的硬连接的时候，i\_nlink 就会增加。

##### 对于 rm 而言，就是减少 i\_nlink。这里就出现一个问题，如果一个文件正在被某个进程调用，而用户却执行 rm 操作把文件删除了，会出现什么结果呢？

##### 当用户执行 rm 操作后，ls 或者其他文件管理命令不再能够找到这个文件，但是进程却依然在继续正常执行，依然能够从文件中正确的读取内容。这是因为，rm 操作只是将 i\_nlink 置为 0 了；由于文件被进程引用的缘故，i\_count 不为 0，所以系统没有真正删除这个文件。i\_nlink 是文件删除的充分条件，而 i\_count 才是文件删除的必要条件。

#### 如何用Linux命令统计文件中每个单词出现的词频

##### cat file \| grep -o word \| wc -l

#### Linux命令：找一个文件中包含某字符的行（及行数）

##### find log.txt \| xargs cat \| grep .\*helloworld.\*\|wc -l

###### xargs

####### 它能够捕获一个命令的输出，然后传递给另外一个命令

#### 假如日志中有若干行为user\_id: %d, login\_time: %date 的格式，如果写linux命令去提取这些id和日期怎么写？（不会）

##### awk

### shell

#### 工具

##### grep

###### grep --color=auto 'test' test.txt

####### 高亮显示

####### alias grep='grep --color=auto'

###### grep -n 'test' test.txt

####### 显示行号

###### -i

####### 忽略大小写

####### ignore

###### \^或\$

####### 显示以关键字开头或者结尾的行

####### grep '\^test' test.txt

###### -v

####### 除了关键字那一行，其他行都显示出来

###### -B 3

####### before

######## 前3行

####### grep -B 3 '\^test' test.txt

######## 显示以test开头的行的前三行

###### -A 3

####### after

######## 后三行

####### grep -A 3 '\^test' test.txt

######## 显示以test开头的行的前三行

###### -C 3

####### 上下文，前后3行

###### -o

####### 只打印关键字本身

####### only，仅匹配

###### -e

####### 使用正则表达式

##### cut

###### 列截取工具

####### cut 选项 文件名

###### -c

####### 以字符为单位进行分割，截取

####### cut -c3 test.txt

######## 截取每行第三列的内容

####### cut -c3-6 test.txt

######## 截取每行3～6列的内容

####### cut -c3- test.txt

######## 截取每行第三列及以后的内容

###### -d

####### 自定义分割符，默认为制表符\\t

######## tab

####### cut -d, -f1 test.txt

######## 以逗号分割，截取第一列内容

###### -f

####### 与-d一起使用，指定截取哪个区域

##### sort

###### sort

####### 将每一行作为一个单位，按照ASCII码排序

####### -u

######## 去除重复的行

####### -r

######## 降序排列

####### -o

######## 将排序结果输出到文件中，类似\>

####### -n

######## 以数字排序，默认按字符排序

####### -t

######## 分隔符

####### -k

######## 第N列

####### -b

######## 忽略前导空格

####### -R

######## 随机排序，每次运行结果不同

##### uniq

###### 去除连续的重复的行

###### -c

####### 统计重复行次数

###### -i

####### 忽略大小写

###### -d

####### 只显示重复行

##### tee

###### 从标准输入读取并写入到标准输出和文件，即双向覆盖重定向（屏幕输出｜文本输入）

####### 默认是覆盖的

###### -a

####### 双向追加重定向

###### echo hello\|tee 1.txt

##### diff

###### 逐行比较两个文件不同

####### diff 【选项】 文件1 文件2

###### -b

####### 不检查空格

###### -B

####### 不检查空白行

###### -i

####### 忽略大小写

##### paste

###### 合并文件行

###### -d

####### 自定义间隔符，默认tab

###### -s

####### 串行处理，非并行

##### tr

###### 字符转换，替换和删除，主要用于文件中控制字符或进行字符转换

###### tr -d 'a-zA-Z '

####### 删除

####### -d删除字符串中所有输入字符

###### tr ' ' '\\n'

####### 替换

###### tr -s ' '

####### 压缩空格

####### -s 删除所有重复出现字符序列，只保留第一个;即将重复出现字符串压缩为一个字符串

#### bash特性

##### 常见快捷键

###### tab

####### 补全命令和文件

###### \^u

####### 删除光标前所有字符

###### \^k

####### 删除光标后所有字符

###### \^z

####### 将当前程序挂起到后台

###### \^l

####### 清屏

###### \^r

####### 搜索历史命令

##### 常见通配符

###### \*: 匹配0或多个任意字符

###### ?: 匹配任意单个字符

###### \[list\]: 匹配\[list\]中的任意单个字符,或者一组单个字符 \[a-z\]

###### \[!list\]: 匹配除list中的任意单个字符

###### {string1,string2,...}:匹配string1,string2或更多字符串

##### bash中的引号

###### 双引号"" :会把引号的内容当成整体来看待，允许通过\$符号引用其他变量值

###### 单引号'' :会把引号的内容当成整体来看待，禁止引用其他变量值，shell中特殊符号都被视为普通字符

###### 反撇号\`\` :反撇号和\$()一样，引号或括号里的命令会优先执行，如果存在嵌套，反撇号不能用

#### shell脚本

##### \#!bin/bash

###### 指定bash解释器

###### \#!/bin/env bash

####### 如果直接将解释器路径写死在脚本里，可能在某些系统就会存在找不到解释器的兼容性问题，所以可以使 用:\#!/bin/env 解释器

##### 脚本执行

###### -n

####### 用来查看脚本的语法是否有问题

###### bash -x first\_shell.sh

####### -x:一般用于排错，查看脚本的执行过程

###### source shelltext.sh

####### 使用 source 命令读取脚本文件,执行文件里的代码

##### 变量

###### A=hello

####### 定义变量

###### echo \$A

####### 调用变量A

####### 或echo \${A}

######## echo \${A:2:4} 3456 表示从A变量中第3个字符开始截取，截取4个字符

###### unset A

####### 取消变量

###### 变量名区分大小写，不能有特殊符号，不能以数字开头，等号两边不能有空格

###### 交互式定义变量

####### read name

######## -p

######### 定义提示用户的信息

######## -n

######### 定义字符数（限制变量值的长度）

###### 变量的分类

####### 本地变量

######## 当前用户自定义的变量。当前进程中有效，其他进程及当前进程的子进程无效。

####### 环境变量

######## 当前进程有效，并且能够被子进程调用。

######## env 查看当前用户的环境变量

######## set 查询当前用户的所有变量(临时变量与环境变量)

######## export 变量名=变量值 或者 变量名=变量值;export 变量名

####### 全局变量

####### 系统变量

######## \$?

######### 上一条命令执行后返回的状态;状态值为0表示执行正常，非0表示执行异常或错误

######## \$\#

######### 脚本后面接的参数的个数

######## \$\*

######### 脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开

######## \$@

######### 脚本后面所有参数，参数是独立的，也是全部输出

########## \$\* :表示将变量看成一个整体 \$@ :表示变量是独立的

######## \$\$

######### 当前所在进程的进程号，如echo \$\$

######## \$1\~\$9

######### 脚本后面的位置参数，\$1表示第一个位置参数

###### 简单四则运算

####### 四则运算符号

######## 加(+)、减(-)、乘(\*)、除(/)、求余数(%)

######## \$(( ))

######### echo \$((1+1))

######## \$\[ \]

######### echo \$\[10-5\]

######## expr

######### expr 10 / 5

######## let

######### n=1;let n+=1 等价于 let n=n+1

####### i++和++i

######## let x=i++

######### 先赋值，再运算

######## let y=++j

######### 先运算，再赋值

###### 数组

##### 条件判断

###### 条件判断

####### 格式1: test 条件表达式

####### 格式2: \[ 条件表达式 \]

######## 两边都要加空格

####### 格式3: \[\[ 条件表达式 \]\] 支持正则 =\~

###### 判断文件类型

####### -e 判断文件是否存在(任何类型文件)

######## \[ -e sysvar3.sh \];echo \$?

######## test -e sysvar.sh echo \$?

####### -s 判断文件是否存在并且是一个非空文件(有内容)

####### test -e file

####### \[ -d /shell01/dir1 \]

####### \[ ! -d /shell01/dir1 \]

######## 判断目录是否存在,不存在条件为真

####### \[\[ -f /shell01/1.sh \]\]

###### 判断文件新旧

####### test file1 -nt file2

######## 比较file1是否比file2新

####### file1 -ot file2

######## 比较file1是否比file2旧

####### file1 -ef file2

######## 比较是否为同一个文件

###### 判断整数

####### -eq

######## 相等

####### -ne

######## 不等

####### -gt

######## 大于

####### -lt

######## 小于

####### -ge

######## 大于等于

####### -le

######## 小于等于

###### 判断字符串

####### -z

######## 断是否为空字符串，字符串长度为0则成立

####### -n

######## 判断是否为非空字符串，字符串长度不为0则成立

####### string1 = string2

######## 断字符串是否相等

####### string1 != string2

######## 判断字符串是否相不等

###### 多重条件判断

####### -a 和 &&

######## 逻辑与

######### \[ 1 -eq 1 -a 1 -ne 0 \] \[ 1 -eq 1 \] && \[ 1 -ne 0 \]

####### -o 和 \|\|

######## 逻辑或

######### \[ 1 -eq 1 -o 1 -ne 1 \]

##### 流程控制

###### if结构

####### if \[ condition \];then command command fi

###### if...else结构

####### if \[ condition \];then command1 else command2 fi

###### if...elif...else结构

###### 案例

####### \#!/bin/env bash \# 该脚本用于判断当前主机是否和远程指定主机互通 \# 交互式定义变量，让用户自己决定ping哪个主机 read -p "请输入你要ping的主机的IP:" ip \# 使用ping程序判断主机是否互通 ping -c1 \$ip &\>/dev/null if \[ $? -eq 0 ];then echo "当前主机和远程主机$ip是互通的\" else echo "当前主机和远程主机\$ip不通的" fi 逻辑运算符 test $? -eq 0 && echo "当前主机和远程主机$ip是互通的\" \|\| echo "当前主机和远程主机\$ip不通的"

####### ping -c表示ping次数

##### 循环语句

###### 列表循环

####### for variable in {list} do command command ... done

###### 不带列表循环

####### 不带列表的for循环执行时由用户指定参数和参数的个数

###### 类C风格的for循环

####### for (( i=1;i\<=5;i++)) do echo \$i done

###### 脚本计算1-100奇数和

####### for i in {1..100..2}

####### for ((i=1;i\<=100;i+=2))

######## let sum=$i+$sum

######## sum=$[$i+\$sum\]

###### 循环控制语句

####### 循环体：do....done之间的内容

####### continue:继续;表示循环体内下面的代码不执行，重新开始下一次循环 break:打断;马上停止执行本次循环，执行循环体后面的代码 exit:表示直接跳出程序

###### 判断所输整数是否为质数

###### while

###### until

####### 条件为假就进入循环;条件为真就退出循环

## 测试

### 设计微信语音消息测试用例

### 设计微信朋友圈测试用例

#### 功能测试

##### 朋友圈发送功能

###### 只发送文本

####### 文本长度

####### 文本类型（中英文，数字，表情，url）

####### 文本是否支持复制粘贴

####### 空校验

###### 只发送图片

####### 本地相册选择/拍摄

####### 图片数量

####### 图片格式，动图

####### 图片尺寸

####### 图片大小

####### 图片的增删编辑

####### 视频预览增删改

####### 为空校验

###### 发送文本和图片/视频

###### 内容是否涉及敏感词

###### 所在位置

###### 谁可以看

###### 提醒谁看

###### 同步qq空间

###### 取消操作

##### 朋友圈浏览功能

###### 文本查看

####### 过长文本是否隐藏，支持查看全文

####### 可复制

####### url链接是否支持跳转

###### 图片查看

####### 是否可以保存

####### 可以缩放

####### 可收藏

###### 视频播放

##### 点赞

##### 评论回复

##### 删除动态

##### 相册封面

#### 界面

#### 网络测试

##### 弱网

###### 延时

###### 丢包

#### 兼容性

#### 安全

##### 文本输入脚本代码，是否出现异常

#### 性能

##### 服务器性能

###### tps

###### 响应时间

###### 吞吐量

###### cpu

###### 内存

##### app客户端

###### cpu

###### 内存

###### 流量

###### 电量

##### app压力稳定性测试

###### 频繁发送朋友圈，浏览朋友圈请求，是否崩溃

### 设计微信收藏表情包和发送表情包的测试用例

### 朋友圈的点赞功能怎么设计测试点？

#### UI

#### 功能

##### 点赞后显示已赞

##### 未点赞时显示赞

##### 点赞数+1

###### 显示头像和昵称

##### 共同好友视角

##### 非共同好友视角

##### 数据库写入是否正常

##### 自己点赞是否通知其他人

##### 共同好友点赞是否通知其他人

##### 取消点赞

#### 异常

##### 点赞后昵称变更，点赞栏是否更新

##### 弱网

###### Fiddler，Charles，Qnet

##### 断网

#### 兼容

#### 压力

##### 多人点赞，一条朋友圈可以有多少点赞

###### 加载是否崩溃

### 设计百度首页测试用例

### 编写一个登录界面的测试用例

#### ui

#### 功能测试

##### 空校验

##### 用户名密码长度

##### 密码是否显示

##### 是否区分大小写

##### 忘记密码

##### 密码错误

##### 不存在的用户名

##### 记住用户

##### 是否支持特殊字符

#### 性能测试

##### 点击登陆后的时延

#### 可用性

##### 按回车是否可以登陆

##### tab键切换

#### 安全测试

##### 是否通过加密的方式发给web服务器

##### 用户名密码的验证应该是在服务器端

##### 禁止输入脚本

##### 错误登陆次数

##### 不同机器同一个账户登陆

##### 是否采用https技术

##### 密码是否保存在本地cookie中

#### 压力测试

##### 大量并发用户登陆，系统响应时间

#### 稳定性

##### 并发用户数在临界点连续登陆几个小时

#### 异常

##### 弱网

### 登录的按钮不能点击如何排查问题

#### 浏览器崩溃

#### 网络故障

#### 用户名密码错误

#### 手机故障

#### js代码错误

### 微信红包测试用例

### 一支铅笔测试

#### 外表

##### 尺寸

##### 色彩

##### 形状

##### logo

#### 功能测试

##### 笔筒开合

##### 笔芯替换

##### 出墨快慢

##### 出墨粗细

#### 性能测试

##### 笔芯寿命

##### 笔墨气味

##### 用水浸透笔墨会不会散开

##### 压力测试

###### 笔尖在多大压力范围可以正常写字

###### 笔壳在多大压力范围可以正常使用

##### 能在哪些纸上写出字来

##### 握笔的地方纹路滑不滑

##### 流畅度

##### 墨水多久能干

##### 高低温环境对墨水的影响

##### 长时间不戴笔套会不会影响书写

#### 安全测试

##### 笔摔了会不会坏

##### 笔墨是否有易燃性

##### 对皮肤是否有伤害

##### 误食笔墨是否会中毒

##### 笔杆折断会不会容易扎伤手

#### 兼容性测试

##### 笔尖摔坏了，换其他笔芯的尖能不能使用

#### 竞品测试

##### 与其他笔比较优势

### 短视频测试

#### 短视频最主要的功能就是拍摄视频、编辑视频、播放视频

##### 拍摄视频

###### 拍摄清晰度测试

###### 卡顿测试

###### 草稿测试

###### 时间精准测试

##### 播放视频

###### 播放秒开测试

####### 播放器测试

######## 解码性能，软解硬解

####### 预加载、IP直出等策略测试

######## 预加载时机、不同网络下的预加载

####### 竞品对比测试

######## 相同的场景、网络情况，对比竞品

###### 卡顿测试

###### 清晰度测试

###### 音画同步测试

## 智力题

### 一个10升的油桶装满油，两个空油桶，分别为3升和7升，三个油桶均无刻度，如何把10升平均分成5升。

#### 先用3升桶盛满分三次倒入7升桶里，此时3升桶剩2升，10升桶剩1升，把7升桶全倒入10升，此时10升桶有八升，把3升桶全倒入7升桶，把三升桶盛满倒入7升

### 54张扑克牌，分成3份，求大王小王在同一份的概率。

#### 总的分法 M=(C54，18)\*(C36，18)\*(C18，18)

#### 大小王在同一份 N=(C3，1)\*(C52，16)\*(C36，18)\*(C18，18)

#### N /M=17/53

### 给8个小球，7个质量相同，一个重一点，给你一个天平，称几次可以称出来。（2次）

#### 3，3，2

### 一硬币，一面向上概率0.7，一面0.3，如何公平

#### 第一次正面，第二次反面：p \* (1 - p)

#### 第一次反面，第二次正面：(1 - p) \* p

### 两根香，一根烧完1小时，如何测量15分钟

#### 一根a两头都点，另一个b只点一头，a烧完了再把b另一头点燃

### 如果你有4G内存，保存所有结果序列而不是直接打印，你觉得K能开多大？

### 疯狗问题

#### 有N只疯狗，则枪声会响在第N天。

### 100个球，两个人轮流拿，每次最多拿5个，拿到最后一个球的人赢。自己先拿，怎么样保证自己必赢

#### 先拿4个，然后对方拿n个，我就拿6-n个

#### 100/6=16.4

### 10堆苹果，每堆10个，9堆每个50g，1堆每个40g，有一个称，求只称一次，找出这个轻的一堆

#### 从第n堆里取n个，,缺几克/10就是第几堆

### 过桥

#### 小明一家人过一座桥,过桥的时候是黑夜,所以必须有灯.现在小明过桥要1秒,小明的弟弟要3秒,小明的爸爸要6秒,小明的妈妈要8秒,小明的爷爷要12秒.每次此桥最多可过两人,而过桥的速度依过桥最慢者而定,而且灯在点燃后30秒就会熄灭,问小明家如何过桥?

##### 1.小明带着弟弟过桥，小明回来。用了4s

##### 2.小明带着爸爸过桥，弟弟回来，用了6+3s

##### 3.爷爷和妈妈过桥，小明回来，用了13s

##### 4.小明和弟弟过桥，用了3s

#### 一个人带着一只羊、一只狼、和一筐草，过桥而那座桥只能承受两种东西，问：他怎么能安全的全部过去呢？

##### 先把羊放过去，回来再把狼放过去，把羊接回来，把草放过去，最后把羊放过去

### 大文件

#### 在超大文件中找出访问百度次数最多的IP

##### 1）面试中若题目提到大文件等，其实就是告诉你数据量大，不能一次性加载到内存中，而实际中我们就需要估算。既然是要对访问百度次数的ip做统计，我们最好先预处理一下，遍历把访问百度的所有ip写到另一个文件a中

##### （2）ip用32位表示，所以最多有2\^32个不同ip地址。同样的，当内存不能一次性加载数据时，我们就需要考虑分治法。

###### step1：采用hash映射(hash(ip)%1000)分别把结果保存到小文件a0....a999中。有人可能会问,这里一定要用1000吗？当然不一定，需要估算，比如若文件a总共320G远远大于4G内存，我们就需要分块（hash映射），若分为1000块，则每块大约300M，再读入内存就没问题了。

###### step2：可以采用hash\_map进行频率统计，找出每个小文件中出现频率最大的IP。对于每一个小文件ai，具体操作如下：创建hash\_map,遍历小文件中每条记录。对于每条记录，先在hash\_map中搜索，若有，将hash\_map中记录count+1，若没有，插入hash\_map

###### step3:在这1000个最大的IP中，找出count最大的ip

#### 5亿个数大文件怎么排序？

##### 内存极少的情况下，利用分治策略，利用外存保存中间结果，再用多路归并来排序;

##### 1.分

###### 内存中维护一个极小的核心缓冲区memBuffer，将大文件bigdata按行读入，搜集到memBuffer满或者大文件读完时，对memBuffer中的数据调用内排进行排序，排序后将有序结果写入磁盘文件bigdata.xxx.part.sorted.

###### 循环利用memBuffer直到大文件处理完毕，得到n个有序的磁盘文件：

##### 2.合

###### 

#### 250M内存处理10G大小的log文件

##### 首先。考虑将10G的log文件划分为多个小于250M的文件，这样每一个小文件就能够一次性加载内存了。

##### 当小文件能够一次性加载内存后，能够直接grep搜索，也能够对文件内容排序后，然后二分查找。

#### cat大文件

##### split -l 5000000 filename -d -a 3 filename-part

###### 将文件filename切割成每个文件有5000000行的小文件，切割后的文件名前缀是filename-part+3位数字。

##### cat filename-part\* \> filename-reault

###### 处理完数据之后需要将结果文件进行合并

###### filename-part\*代表所有处理完的小文件，合并成最后的filename-result文件。

### 有1000瓶水，其中有1瓶水有毒，现有10只小白鼠，中毒反应在第七天显示出来，请问如何在第七天测试出哪一瓶水有毒？

#### 思路就是用二进制，2\^10=1024，也就是10只小白鼠最多能验出1024瓶药水，哪个有毒。小白鼠编号，1-10。瓶子也编号，1-1000，然后把瓶子的编号转变为二进制数。如果第几位是1，就把这瓶水给第几个小白鼠喝。最后大概每个小白鼠喝500瓶药水的混合液。

### 你有一个金条，已经切成了7份相连（没有完全分离），你雇佣了一个工人每天给你干活，一共一周，每日支付一个金条的1/7，你最多可以掰2次，问你怎么分配才能满足上述要求

#### 4段+2段+1段

## 负载均衡

### 负载均衡技术

#### dns轮询

##### DNS轮询是最简单的负载均衡方式。以域名作为访问入口，通过配置多条DNS A记录使得请求可以分配到不同的服务器。

#### ip负载均衡

##### 是基于特定的TCP/IP技术实现的负载均衡

#### cdn

### 负载均衡算法有哪些

#### 静态负载均衡

##### 轮询法

###### 将请求按顺序轮流地分配到每个节点上，不关心每个节点实际的连接数和当前的系统负载。

###### 缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响

##### 随机法

###### 将请求随机分配到各个节点。

##### 源地址哈希法

###### 根据客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。

###### 优缺点

####### 相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布

####### 如果某个节点出现故障，会导致这个节点上的客户端无法使用，无法保证高可用。

##### 加权轮询法

###### 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。

###### 给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，

###### 优缺点

####### 优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；

####### 缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。

#### 动态负载均衡

##### 最小连接数法

###### 根据每个节点当前的连接情况，动态地选取其中当前积压连接数最少的一个节点处理当前请求

##### 最快响应速度法

###### 根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。

##### 观察模式法

###### 观察者模式是综合了最小连接数和最快响应度，同时考量这两个指标数，进行一个权重的分配

### 负载均衡的加权轮询算法怎么实现

#### 加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。

### 什么是负载均衡

#### 将请求或者数据分摊到多个操作单元上进行执行，共同完成工作任务。

#### 主要用于解决服务器集群的高并发访问服务问题

#### 目的就通过调度集群，达到最佳化资源使用，最大化吞吐率，最小化响应时间，避免单点过载的问题。

## nginx

### 反向代理

#### 客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。

### 负载均衡

### 动静分离

#### 前端请求静态文件比如图片资源是不需要经过后端服务器的，但是调用API这些类型的就需要后端进行处理请求，所以为了提高对资源文件的响应速度，我们应该使用动静分离的策略去做架构。我们可以将静态文件放到Nginx中，将动态资源的请求转发到后端服务器去进行进一步的处理。

## django

### 讲讲restful（面向资源，一个资源一个url，http层，四种操作）

### 你能解释下MVC的完整流程吗?

#### MVC

## 设计模式

### 写单例模式

#### 饿汉

##### 饿汉式在应用启动时就创建了实例，饿汉式是线程安全的，是绝对单例的。

##### 为什么加锁

###### 加锁可以确保实例化方法只能有一个线程执行，确保两个线程不会同时进入实例化方法。

#### 懒汉

##### 懒汉式在对外提供的获取方法被调用时会实例化对象。在多线程情况下，懒汉模式不是线程安全的

### 简单工厂

#### 定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类

#### 在简单工厂模式中用于被创建实例的方法通常为静态(static)方法,因此简单工厂模式又被成为静态工厂方法(Static Factory Method)

#### 需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，而无需知道其实现过程

##### 工厂可以根据参数的不同返回不同的产品，这就是简单工厂模式

#### 结构

##### Factory：核心部分，负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象

##### IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，封装了产品对象的公共方法

##### Product：具体产品类，是简单工厂模式的创建目标。

### MVC

## git

### Git 底层实现；如何解决冲突？

### 每次提交，检测到校验和变化，就会生成一个新的快照，未更改的文件就会链接到上一次的快照

### git init

#### 初始化一个本地库

### git status

#### 查看本地库，工作区、暂存区状态

### git add

#### 将文件添加到暂存区

### git commit -m ""

### git log

### git reset --hard 局部索引值

#### 版本回退前进

### git diff

### git branch 分支名

#### 创建分支

### git merge

### git如何解决代码冲突

#### git stash 暂存本地仓库代码

#### git pull 拉取新代码

#### git stash pop 合并远程和本地代码

#### git diff -w 查看文档的不同手动解决冲突

### git fetch与git pull的区别

#### git pull = fetch +merge ,下拉远程分支并与本地分支合并。

### 什么是gitflow

#### master 主分支

#### develop 主开发分支，包含确定即将发布的代码

#### feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突

#### release 发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复

#### hotfix hotfix 分支，紧急修 bug 的时候用

### github使用

#### 远程库

##### 1. 在github上创建一个远程仓库

##### 2. git remote -v 查看当前所有远程地址别名

##### 3. git remote add \[别名\] \[远程地址\]\#\#\#\#别名就是给远程地址取名字

#### 克隆

##### git clone 远程地址

##### 完整的把远程库下载到本地。带有.git，已经初始化好了本地库，且别名也初始化了

#### 推送：

##### git push \[别名\] \[分支名\]

#### 拉取

##### git pull \[远程库地址别名\] \[远程分支名\] pull分为两个操作： fetch和merge petch抓取，git fetch \[远程库地址别名\] \[远程分支名\] 对于远程库来说是读操作。只是把远程文件下载到本地，但是并没有去改工作区的文件。如果想看看抓取的文件， 可以 git checkout origin/master

#### 合并

##### git merge origin/master

## 剑指offer

### 1 数组中重复的数字

#### 原地置换，把索引对应的数字放到数字对应的索引位置上

### 2. 二维数组中的查找

#### if target \>= matrix\[0\]\[0\] and target \<= matrix\[m\]\[n\]: x = 0 while m \>= 0 and x \<= n: if target == matrix\[m\]\[x\]: return True elif target \< matrix\[m\]\[x\]: m -= 1 else: x += 1

### 3 替换空格

#### 使用replace

#### \[\],append，join

#### 两个指针

### 4 从头到尾打印链表

#### \[::-1\]

### 5 重建二叉树

#### 递归

### 6. 用两个栈实现一个队列

### 7. 斐波那契数列

### 8. 青蛙跳台阶

### 9. 旋转数组的最小数字

#### 分三种情况

### 10. 矩阵中的路径

### 11. 机器人的运动范围

### 12. 剪绳子

#### 如果除以3的余数是1，就3\*3\*4

### 13. 二进制中1的个数

#### n = n&(n-1)

### 14.数值的整数次方

#### if n\<0: x,n=1/x,-n temp=1 while n: if n&1: temp\*=x x\*=x n\>\>=1 return temp

### 15. 打印数字

### 16. 删除链表节点

#### pre = ListNode(0) pre.next = head

### 18. 调整数组顺序使奇数位于偶数前面

#### 两个指针

### 19. 链表中倒数第k个节点

### 20. 反转链表

#### 三个指针

### 21. 合并两个排序的链表

#### 构建一个新的链表节点，两个指针

### 22. 判断是否是子树

### 23. 二叉树镜像

#### if not root: return root root.left, root.right = self.mirrortree(root.right),self.mirrortree(root.left)

### 24. 对称的二叉树

#### def isSymmetric2(self, root1, root2):

### 25. 顺时针打印矩阵

### 26. 包含min函数的栈

### 27. 栈的压入、弹出序列

### 28. 从上到下打印二叉树

#### 双端队列

### 33. 复杂链表的复制

### 36. 最小的k个数

#### 大根堆。heapq.heapify(container), heapq.heappop(), heapq.heappush()

### 37. 数据流中的中位数

#### 一个大根堆，一个小根堆

### 38. 数组中出现次数超过一半的数字

#### class Solution: def majorityElement(self, nums: List\[int\]) -\> int: num = nums\[0\] time = 0 for i in range(len(nums)): if nums\[i\] == num: time += 1 else: time -= 1 if time == 0: num = nums\[i\] time = 1 return num

### 40. 连续子数组的最大和

#### class Solution: def maxSubArray(self, nums: List\[int\]) -\> int: for i in range(1,len(nums)): nums\[i\] += max(nums\[i-1\], 0) return max(nums)

### 41 数组翻译字母

#### for i in range(2,l+1): if 25 \>= (int(string\[i-2\])\*10 + int(string\[i-1\])) \>=10: dp0,dp1 = dp1,dp0+dp1 else: dp0,dp1 = dp1,dp1 return dp1

### 44. 最长不含重复字符的子字符串

#### class Solution: def lengthOfLongestSubstring(self, s: str) -\> int: dic = {} l = 0 max\_l = 0 for i in range(len(s)): if s\[i\] not in dic or i - dic\[s\[i\]\] \> l: l += 1 else: l = i - dic\[s\[i\]\] dic\[s\[i\]\] = i if l \>= max\_l: max\_l = l return max\_l

### 47. 链表公共节点

#### class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\> ListNode: p1 = headA p2 = headB while p1 != p2: if not p1: p1 = headB else: p1 = p1.next if not p2: p2 = headA else: p2 = p2.next return p1

### 48. 在排序数组中查找数字

### 58. 反转字符串

#### return \" \".join(s.split()\[::-1\])

## 测试框架

### appium

#### adb

##### 

##### 命令

###### 获取包名和界面名

###### 文件传输

####### adb push 电脑路径 手机路径

####### adb pull 手机路径 电脑路径

###### 获取app启动时间

####### adb shell am start -w 包名/启动名

###### 获取手机日志

####### adb logcat

###### 其他

### jmeter

## 头条

### 求数组中出现次数最多且最大的数

#### 子主题 1

### 抖音有哪些需要改进的地方？刷不出来时怎么定位测试？

### 文本中第一列：\*\*，第二列ip地址，第三列：时间。找出文本中ip地址的个数(存在重复)

#### cat log.txt \|awk -F\" \" '{print \$2}' \|sort\|uniq -c\|sort -k1,nr\|head -10

### 用例设计：百度登陆功能

### 给定一个有序数组A，给定一个目标数字B，查找目标数字B在数组A中出现的起始位置和结束位置

#### 子主题 1

### 设计一个工具类，把post请求封装起来供别人使用，用python

#### 子主题 1

### 一副扑克牌，从中随机抽取5张牌，判断这5张牌是否是顺子。

#### 子主题 1

### 将字符串转为整型

### 文本中替换字符linux

#### sed

##### sed -i 's/abc/xxx/g' file

###### -i表示真的替换，直接修改文件

#### :%s/well/good/g

##### 替换文本中所有well

#### :%s/well/good/

##### 替换文本中每一行的第一个well

### 给一个k值和排序的数组，返回k在数组中的位置

#### 子主题 1

### 输出一个集合的全部子集

#### 子主题 1

### 判断两个链表是否相交

#### 子主题 1

### 6.VI 显示所有行的行号

#### : set number

### 设计一个测试用例(抖音点赞功能)

#### 性能测试、压力测试（并发，时长）、边界值测试、安全性测试、兼容性、功能测试、回归测试

### https://toutiao.com/index.html转成html.index/com.toutiao://https,使用两个栈解决；

#### 子主题 1

### 两个序列的最长公共子序列

#### 子主题 1

### 写个装饰器吧，实现一下输出一个函数运行时间的装饰器

#### 子主题 1

### 比如有test.log文件包含三列（空格隔开）：时间戳 返回码 响应时间，如何获取返回码为200的平均响应时间

#### 子主题 1

### 数据库

#### 数据库查询：id，name,suba,subb,subc,classid,查出每个班 suba课程的成绩大于平均成绩的学生；

##### select id,name,classid,suba from student where suba\>(select avg(suba) as subavg from student);

#### 按照班级分类，找每个班的成绩最高的人；只找最高成绩\>90的班级

##### SELECT name,suba from (select classid,max(suba) as maxsuba from student GROUP BY classid) as t1 INNER JOIN student ON t1.classid=student.classid and t1.maxsuba=student.suba;

##### select classid,max(suba) as maxsuba from student GROUP BY classid having maxsuba\>79;

#### mysql创建一个学生表，包含id（int）和name（string），主键的创建

##### CREATE TABLE student (id INT, NAME CHAR,PRIMARY KEY (id))ENGINE=INNODB;

## mysql命令

### 唯一标识每一行的列称为主键

### 限制结果

#### select \* from table limit 3,4;

##### 从行三开始显示4行

### 检索不同的行

#### select distinct value from table

##### 只返回不同的值

### 排序

#### order by

##### order by name,price

###### 首先按名称，其次按价格

##### 指定排序方向

###### desc降序

### 过滤

#### where

##### between 5 and 10

##### in （1002，1003）

#### 通配符

##### like

###### 百分号

####### where name like 'jet%'

##### \_

###### 下划线

####### where name like '\_ ton anvil'

####### 只匹配单个字符

#### 正则表达式

##### regexp

### 创建计算字段

#### 拼接

##### 将值联结到一起构成单个值

##### concat（rtrim(name),'(',rtrim(country),')'）

###### rtrim

####### 去掉右边空格

##### as

### 汇总数据

#### 聚集函数

##### avg()返回某列的平均值

###### 聚集不同值

####### avg(distinct price) as avg\_price

##### count()某列的行数

##### max()某列最大值

##### min()某列最小值

##### sum()某列值之和

###### 子主题 1

### 分组数据

#### select vend\_id, count(\*) as num\_prods from products group by vend\_id

##### group by子句指示mysql按vend\_id排序并分组数据。这导致对每个vend\_id而不是整个表计算num\_prods一次

#### 过滤分组

##### having

###### select vend\_id, count(\*) as num\_prods from products group by vend\_id having count(\*)\>=2

#### 分组和排序

##### order by

###### 排序产生的输出

##### group by

###### 分组行

###### 如果和聚集函数一起使用列，则必须使用

#### select子句顺序

##### select from where group by having order by limit

### 联结表

#### 外键

##### 某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系

#### 内联结

##### 等值联结，基于两个表之间的相等测试

##### 结果：为两个联接表中的匹配行的联接

##### 内连接是从结果表中删除与其他被连接表中没有匹配行的所有行，所以内连接可能会丢失信息。

#### 外部联结

##### 联结包含了那些在相关表中没有关联行的行

##### 左联结

###### 以左表为主表，右表没数据为null

###### 如果左表的某行在右表中没有匹配行，则将为右表返回空值

##### 右联结

###### 右表的某行在左表中没有匹配行，则将为左表返回空值

#### 创建联结

##### where vendors.vend\_id=products.vend\_id

### 全文本搜索

#### where match(note\_text) against('rabbit')

##### match指定被搜索的列，against指定要使用的搜索表达式

### 插入数据

#### insert into table values(1,2,3,4)

### 更新和删除数据

#### update table set email="1234" where id=1

#### delete from table where id=1

### 创建表

#### create table customers(id int not null,default=1) engine=innodb;

### 更新表

#### alter table vendors add vend\_phone char(20)

##### 增加一列

### 删除表

#### drop table customers;

##### 不能撤销

##### 删除表结构

## restful

### rest

#### 表现层状态转换

##### 表现层

###### REST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。 所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的URI。

##### 状态转化

###### 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

### 什么是RESTful架构

#### 　　（1）每一个URI代表一种资源；

#### 　　（2）客户端和服务器之间，传递这种资源的某种表现层；

#### 　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

## docker

### 画一下Docker的架构图

### Docker的镜像是如何运行成容器的？

### 三个基本概念

#### 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。

#### 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

#### 仓库（Repository）：仓库可看着一个代码控制中心，用来保存镜像。

### dockerfile命令

#### FROM：指定基础镜像

#### LABEL：功能是为镜像指定标签

#### RUN：运行指定的命令

#### CMD：容器启动时要运行的命令

### docker命令

#### 镜像

##### 查看镜像

###### docker images

###### docker images -q

####### 查看所有镜像id

##### 搜索镜像

###### docker search redis

##### 拉取镜像

###### docker pull redis

##### 删除镜像

###### docker rmi redis:latest

#### 容器

##### 查看容器

###### docker ps

####### 查看正在运行的容器

###### docker ps -a

####### 查看所有容器

##### 创建容器

###### docker run -it --name=c1 redis:5.0 /bin/bash

####### -it创建的容器一般称为交互式容器，-id创建的容器一般称为守护式容器

####### /bin/bash 表示启动容器后启动bash

####### -i保持容器运行

##### 进入容器

###### docker exec

##### 启动容器

###### docker start c2

##### 停止容器

###### docker stop

##### 删除容器

###### docker rm c1

##### 查看容器信息

###### docker inspect c2

#### 数据卷

##### docker容器删除后，在容器中的数据也随之删除。因此要把数据挂载到宿主机

##### 容器数据持久化

##### 外部机器和容器间接通信

##### 容器之间数据交换

##### -v设置数据卷

###### docker run -it --name=c3 -v /volume redis:5.0 /bin/bash

#### docker镜像原理

##### 分层的文件系统

##### docker中一个centos镜像为什么只有200m，而一个centos操作系统的iso文件要几个G？

###### docker的centos复用了宿主机的bootfs。

###### centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层

##### docker中一个tomcat镜像为什么有500m，而一个tomcat安装包只有70多m？

###### 由于docker中镜像是分层的，tomcat虽然只有70多m，但是他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多m

##### linux文件系统由bootfs和rootfs两部分组成

###### bootfs：包含bootloader（引导加载程序）和kernel（内核）

###### rootfs：root文件系统，包含的就是典型linux系统中的/dev，/proc，/bin，/etc等标准目录和文件

###### 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等

##### docker镜像原理

###### docker镜像是由特殊的文件系统叠加而成

###### 最底端是bootfs，并使用宿主机的bootfs

###### 第二层是root文件系统rootfs，称为base image

###### 再往上可以叠加其他的镜像文件

###### 统一文件系统技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统

###### 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像称为基础镜像

###### 当从一个镜像启动容器时，docker会在最顶层加载一个读写文件系统作为容器

##### dockerfile

###### dockerfile是一个文本文件

###### 包含了一条条的指令

###### 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像

###### 对于开发人员：可以为团队提供一个完全一致的开发环境

###### 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了

###### 对于运维人员：在部署时，可以实现应用的无缝移植

###### 自定义支持vim的centos

####### 定义父镜像：FROM centos:lasted

####### 定义作者信息：MAINTAINER wuchunbo`<wuchunbo@q163.com>`{=html}

####### 执行安装vim命令：RUN yum install -y vim \#\#\#\#安装软件时会提示yesorno，-y

####### 定义默认的工作目录：WORKDIR /usr

####### 定义容器启动时执行的命令：CMD /bin/bash

####### docker build -f ./centos\_dockerfile -t wcb\_centos:1 .

######## .:dockerfile在当前目录下，则使用 .来指定；否则使用相对路径/path.

######## -f 指定文件路径

######## -t设置新的镜像名称及版本

######## 每一行构建一层

##### docker和虚拟机

###### 启动时间：Docker秒级启动，虚拟机分钟级启动。

###### 轻量级：docker镜像大小通常以M为单位，虚拟机以G为单位。容器资源占用小，要比虚拟机部署更快速。

###### 性能：docker共享宿主机内核，系统级虚拟化，占用资源少，没有Hypervisor层开销，性能基本接近物理机; 虚拟机需要Hypervisor层支持，虚拟化一些设备，具有完整的GuestOS，虚拟化开销大，因而降低性能，没有容器性能好。

###### 安全性：由于共享宿主机内核，只是进程级隔离，因此隔离性和稳定性不如虚拟机，docker具有一定权限访问宿主机内核，存在一定安全隐患。

###### 使用要求：VM基于硬件的完全虚拟化，需要硬件CPU虚拟化技术支持; docker共享宿主机内核，可运行在主流的Linux发行版，不用考虑CPU是否支持虚拟化技术。

###### 总结：虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。

###### 虚拟机需要完整的操作系统，浪费资源。一台机器只能开几个虚拟机。

###### 容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。

###### 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统

## 爬虫

### 爬虫一个请求从开始到收到响应的整个过程？
